var documenterSearchIndex = {"docs":
[{"location":"manual/hubbard_atom/#Hubbard-Atom-as-a-Test-Case","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"One may use the Hubbard atom model to benchmark the Feynman diagrams generated by FeynmanDiagram.jl. In this note, we derive the vertex functions and their power expansion in interaction. The test is implemented in the test folder.","category":"page"},{"location":"manual/hubbard_atom/#1-Hamiltonian","page":"Hubbard Atom as a Test Case","title":"1 Hamiltonian","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"hatH=U n_uparrow n_downarrow-mu (n_uparrow+n_downarrow)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"where U is the on-site interaction, mu is the chemical potential.","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"The eigenstates are,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"left 0 right\n: E_0=0.\nleft uparrow right\nand left downarrow right : E_1=-mu.\nleft uparrow downarrow right\n: E_2=U-2mu.","category":"page"},{"location":"manual/hubbard_atom/#2-Partition-sum","page":"Hubbard Atom as a Test Case","title":"2 Partition sum","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Z=1+2e^mubeta+e^-beta(U-2mu)","category":"page"},{"location":"manual/hubbard_atom/#3-Two-point-Green's-function","page":"Hubbard Atom as a Test Case","title":"3 Two-point Green's function","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For the imaginary-time tau0,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=lefttextT c_uparrow(tau) c^+_uparrow(0) right=frac1Zsum_n left nrighte^-(beta-tau)Hc_uparrow e^-tau H c^+_uparrow left n right","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Only the states left 0 right and left downarrow right contribute,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=frace^mu tau+e^mu betae^-(U-mu)tauZ","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For example, at half filling mu=U2, there is one particle and,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=frace^-Utau2+e^-U(beta-tau)22(1+e^-Ubeta2)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Transform to the Matsubara frequency,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(iomega_n) = int_0^beta G(tau)e^iomega_ntau dtau","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(iomega_n)=-frac1Zleft(frac1+e^mu betaiomega_n+mu+e^mubetafrac1+e^-(U-mu)betaiomega_n-(U-mu)right)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"By setting U=0, one can show that the above dressed Green's function reduce to the bare one,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"g(iomega_n) = -frac1iomega_n+mu","category":"page"},{"location":"manual/hubbard_atom/#4-Self-energy","page":"Hubbard Atom as a Test Case","title":"4 Self-energy","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"The self-energy is defined as G^-1(iomega_n)=g^-1(iomega_n)-Sigma(iomega_n), so that","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Sigma(iomega_n) = fracU e^beta  mu  (mu +i w) left(e^beta  mu +e^beta  Uright)e^beta  U (-mu +U-i w)+e^beta  (mu +U) (-2 mu +U-2 i w)-e^2 beta  mu  (mu +i w)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For benchmark purpose, here we also provide the power expansion of the self-energy at the low-energy limit omega_0 = pi beta with mu=0,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Sigma(iomega_0) = -fracU2+frac(pi +2 i) beta  U^28 pi -fracleft(pi ^2-4right) beta ^2 U^332 pi ^2-fracleft(24 i-12 pi +6 i pi ^2+pi ^3right) beta ^3 U^4384 pi ^3+fracleft(-48-48 i pi -24 pi ^2+12 i pi ^3+5 pi ^4right) beta ^4 U^51536 pi ^4+Oleft(U^6right)","category":"page"},{"location":"lib/operator/#Quantum-operator-and-its-product","page":"Quantum operator and its product","title":"Quantum operator and its product","text":"","category":"section"},{"location":"lib/operator/#API","page":"Quantum operator and its product","title":"API","text":"","category":"section"},{"location":"lib/operator/","page":"Quantum operator and its product","title":"Quantum operator and its product","text":"Modules = [FeynmanDiagram.QuantumOperators]","category":"page"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.OperatorProduct","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.OperatorProduct","text":"struct OperatorProduct <: AbstractVector{QuantumOperator}\n\nstruct of a quantum-operator product. It is a subtype of `AbstractVector` and\ninherits a large set of Vector behaviors including iteration and indexing.\n\nMembers:\n\noperators::Vector{QuantumOperator}  vector of quantum operators\n\n\n\n\n\n","category":"type"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.QuantumOperator","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.QuantumOperator","text":"struct QuantumOperator\n\nstruct of a quantum operator.\n\nMembers:\n\noperator::Datatype: type of quantum operator, supports :f⁺, :f⁻, :f, :b⁺, :b⁻, :ϕ\nlabel::Int:  label of the operator indices. It could represent spacetime, spin, momentum, flavor, etc.\nis_ghost::Bool: whether the operator is a ghost operator or not.\n\n\n\n\n\n","category":"type"},{"location":"lib/operator/#Base.:*-Tuple{QuantumOperator, QuantumOperator}","page":"Quantum operator and its product","title":"Base.:*","text":"Base.:*(o1::Union{QuantumOperator, OperatorProduct}, o2::Union{QuantumOperator, OperatorProduct})\n\n`o1 * o2` returns the quantum operator product of `o1` and `o2`\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#Base.adjoint-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"Base.adjoint","text":"Base.adjoint(o::OperatorProduct)\n\nReturn the conjuated composite operator of `o`.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#Base.adjoint-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"Base.adjoint","text":"Base.adjoint(operator::QuantumOperator)\n\nReturn the conjuated quantum operator of operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.correlator_order-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.correlator_order","text":"function correlator_order(operator::OperatorProduct)\nfunction correlator_order(operator::OperatorProduct)\n\nConvert a OperatorProduct to correlator-ordered form. \nReturns the associated statistical sign and permutation.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.fermionic_annihilation-Tuple{Any}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.fermionic_annihilation","text":"Create a OperatorProduct with one quantum operator from given label `i`.\nIt supports the following abbreviated function form:\n\n''' const 𝑓⁻ = fermionicannihilation const 𝑓⁺ = fermioniccreation const 𝑓 = majorana const 𝑏⁻ = bosonicannihilation const 𝑏⁺ = bosoniccreation const 𝜙 = real_classic '''\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.isannihilation-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.isannihilation","text":"function isannihilation(operator::QuantumOperator)\n\nCheck if operator is an annihilation operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.iscreation-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.iscreation","text":"function iscreation(operator::QuantumOperator)\n\nCheck if operator is a creation operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.isfermionic-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.isfermionic","text":"function isfermionic(o::OperatorProduct)\n\nCheck if `o` is a fermionic composite operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.isfermionic-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.isfermionic","text":"function isfermionic(operator::QuantumOperator)\n\nCheck if operator is a fermionic operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.normal_order-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.normal_order","text":"function normal_order(operator::OperatorProduct)\n\nComputes the permutation required to convert a OperatorProduct to normal-ordered form. \nReturns the associated statistical sign and permutation.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.parity-Tuple{AbstractVector{Int64}}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.parity","text":"The parity of a permutation P is +1 if the number of 2-cycles (swaps) in an n-cycle decomposition with n ≤ 2 is even, and -1 if the number of 2-cycles is odd.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.parity_old-Tuple{Any}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.parity_old","text":"calculate the parity of a given permutation of the array [1, 2, 3, ...]\n\n\n\n\n\n","category":"method"},{"location":"lib/backend/#Compilers-compile-computational-graphs-to-optimized-source-code-for-diverse-platforms","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"Compilers compile computational graphs to optimized source code for diverse platforms","text":"","category":"section"},{"location":"lib/backend/#API","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"API","text":"","category":"section"},{"location":"lib/backend/","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"Compilers compile computational graphs to optimized source code for diverse platforms","text":"Modules = [FeynmanDiagram.Compilers]","category":"page"},{"location":"lib/backend/#FeynmanDiagram.Compilers.compile-Tuple{AbstractVector{<:AbstractGraph}}","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"FeynmanDiagram.Compilers.compile","text":"function compile(graphs::AbstractVector{<:AbstractGraph}; root::AbstractVector{Int}=[id(g) for g in graphs])\n\nCompile a list of graphs into a julia static function.  The function takes two arguments: root and leaf. root is a vector of the root node ids of the graphs, and leaf is a vector of the leaf node ids of the graphs.  This function calls tojuliastr and generate a defined function using RuntimeGeneratedFunctions. Comparing to eval(Meta.parse(tojuliastr(...))), this function does not leak out the function name into global scope.\n\nExample:\n\nfactor = 1.5\nV1 = [𝑓⁺(1)𝑓⁻(2), 𝑓⁺(3)𝑓⁻(4)]\nsubgraphs = [external_vertex(V1[1]), external_vertex(V1[2])]\ng = FeynmanGraph(subgraphs; factor=factor)\n# println(g)\neval_graph! = Compilers.compile([g,])\nroot = [0.0,]\nleaf = [1.0, 2.0]\n\n@assert eval_graph!(root, leaf) ≈ (leaf[1] + leaf[2]) * factor\n\n\n\n\n\n","category":"method"},{"location":"lib/backend/#FeynmanDiagram.Compilers.compile_C-Tuple{AbstractVector{<:AbstractGraph}, String}","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"FeynmanDiagram.Compilers.compile_C","text":"function compile_C(graphs::AbstractVector{<:AbstractGraph}, filename::String; \n    datatype::DataType=_dtype.weight, root::AbstractVector{Int}=[id(g) for g in graphs], func_name=\"eval_graph\")\n\nCompiles a set of graphs into C language code and append the generated code to a specified file.\n\nArguments\n\ndatatype::DataType: This type is used for variables types in the generated C code.\ngraphs::AbstractVector{<:AbstractGraph}: An array of graph objects. These graphs are processed to generate Julia code.\nfilename::String: The name of the file to which the generated code will be appended. The file is created if it does not exist.\nroot::AbstractVector{Int} (keyword): An array of integers representing root nodes for each graph in graphs. By default, it is an array of IDs obtained by calling id(g) for each graph g in graphs.\nfunc_name::String (keyword): The base name for the function(s) to be generated. Defaults to \"eval_graph\".\n\nReturns\n\nA dictionary (leafmap) that maps the index of the leaf weight's table leafVal to the leaf graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/backend/#FeynmanDiagram.Compilers.compile_Julia-Tuple{AbstractVector{<:AbstractGraph}, String}","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"FeynmanDiagram.Compilers.compile_Julia","text":"function compile_Julia(graphs::AbstractVector{<:AbstractGraph}, filename::String; \n    root::AbstractVector{Int}=[id(g) for g in graphs], func_name=\"eval_graph!\")\n\nCompiles a set of graphs into Julia code and append the generated code to a specified file.\n\nArguments\n\ngraphs::AbstractVector{<:AbstractGraph}: An array of graph objects. These graphs are processed to generate Julia code.\nfilename::String: The name of the file to which the generated code will be appended. The file is created if it does not exist.\nroot::AbstractVector{Int} (keyword): An array of integers representing root nodes for each graph in graphs. By default, it is an array of IDs obtained by calling id(g) for each graph g in graphs.\nfunc_name::String (keyword): The base name for the function(s) to be generated. Defaults to \"eval_graph!\".\n\nReturns\n\nA dictionary (leafmap) that maps the index of the leaf weight's table leafVal to the leaf graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/backend/#FeynmanDiagram.Compilers.to_dot_str","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"FeynmanDiagram.Compilers.to_dot_str","text":"function to_dot_str(graphs::AbstractVector{<:AbstractGraph}, name::String=\"\")\n\nCompile a list of graphs into a string for dot language.\n\n# Arguments:\n- `graphs`  vector of computational graphs\n- `title`   The name of the compiled function (defaults to nothing)\n\n\n\n\n\n","category":"function"},{"location":"lib/backend/#FeynmanDiagram.Compilers.to_julia_str-Tuple{AbstractVector{<:AbstractGraph}}","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"FeynmanDiagram.Compilers.to_julia_str","text":"function to_julia_str(graphs::AbstractVector{<:AbstractGraph}, leafMap::Dict{Int,Int}; root::AbstractVector{Int}=[id(g) for g in graphs],\n    name::String=\"eval_graph!\")\n\nCompile a list of Feynman graphs into a string for a julia static function. The complied function takes two arguments: root and leafVal.  root is a vector of the root node ids of the graphs, and leafVal is a vector of the leaf nodes' weights of the graphs. \n\nArguments:\n\ngraphs (AbstractVector{G}): The vector object representing the Feynman graphs,\nroot (AbstractVector{Int}, optional): The vector of the root node ids of the graphs (defaults to [id(g) for g in graphs]).\nname (String,optional): The name of the complied function (defaults to \"eval_graph!\"). \n\nReturns:\n\nA String representing the compiled Julia function.\nleafMap (Dict{Int,G}): A dictionary that maps the index of the leaf weight's table leafVal to the leaf graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/backend/#FeynmanDiagram.Compilers.to_python_str-Tuple{AbstractVector{<:AbstractGraph}}","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"FeynmanDiagram.Compilers.to_python_str","text":"function to_python_str(graphs::AbstractVector{<:AbstractGraph})\n\nCompile a list of graphs into a string for a python static function and output a python script.\n\nArguments:\n\ngraphs  vector of computational graphs\n\n\n\n\n\n","category":"method"},{"location":"lib/backend/#FeynmanDiagram.Compilers.to_static-Tuple{Type, AbstractVector{<:AbstractGraph}, AbstractVector}","page":"Compilers compile computational graphs to optimized source code for diverse platforms","title":"FeynmanDiagram.Compilers.to_static","text":"function to_static(operator::Type, subgraphs::AbstractVector{<:AbstractGraph}, subgraph_factors::AbstractVector)\n\nReturns the static representation of a computational graph node `g` with operator `operator`, subgraphs `subgraphs`, and subgraph factors `subgraph_factors`.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Front-end-generates-Feynman-diagrams-and-translates-then-into-a-computational-graph","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"Front-end generates Feynman diagrams and translates then into a computational graph","text":"","category":"section"},{"location":"lib/frontend/#API","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"API","text":"","category":"section"},{"location":"lib/frontend/","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"Front-end generates Feynman diagrams and translates then into a computational graph","text":"Modules = [FeynmanDiagram.FrontEnds]","category":"page"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.BareGreenNId","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.BareGreenNId","text":"time-ordered N-point Bare Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.BareHoppingId","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.BareHoppingId","text":"hopping function c⁺c⁻\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.ConnectedGreenNId","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.ConnectedGreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.DiagramId","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.DiagramId","text":"abstract type DiagramId end\n\nThe abstract type of all diagrams/subdiagrams/bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.GreenNId","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.GreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.LabelProduct","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.LabelProduct","text":"The cartesian QuantumOperator.label product:\n\n#Parameters:\n\n'LT': Type of labels\n'N' : Number of labels' type\n\n#Members:\n\n'labels' : The list of labels in the LabelProduct\n'dims' : A tuple of the length of the label factors\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.LoopPool","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\nloops::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.PropagatorId","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.PropagatorId","text":"abstract type PropagatorId <: DiagramId end\n\nThe abstract type of all bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#Base.length-Tuple{LabelProduct}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"Base.length","text":"function Base.length(obj::LabelProduct)\n\nReturn the number of grids of the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Base.show-Tuple{IO, LabelProduct}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"Base.show","text":"function Base.show(io::IO, obj::LabelProduct)\n\nPrint the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Base.size-Tuple{LabelProduct, Int64}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"Base.size","text":"function Base.size(obj::LabelProduct, I::Int)\n\nReturn the length of the specifict Ith label factor of the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Base.size-Tuple{LabelProduct}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"Base.size","text":"function Base.size(obj::LabelProduct, I::Int)\n\nReturn the length of the specifict Ith label factor of the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.index_to_linear-Union{Tuple{N}, Tuple{LT}, Tuple{LabelProduct{LT, N}, Vararg{Any}}} where {LT, N}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.index_to_linear","text":"@generated function index_to_linear(obj::LabelProduct{LT,N}, I...) where {LT,N}\n\nConvert a tuple of the indexes of each label to a single linear index of the LabelProduct.\n\nArgument:\n\n'obj': The LabelProduct object\n'index...': N indexes of the label factor, where N is the number of label factor\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.leafstates-Union{Tuple{G}, Tuple{Array{Dict{Int64, G}, 1}, Int64}} where G<:Graph","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.leafstates","text":"function leafstates(leaf_maps::Vector{Dict{Int,G}}, maxloopNum::Int)\n\nExtracts leaf information from the leaf mapping from the leaf value's index to the leaf node for all graph partitions. \nThe information includes their initial value, type, orders, in/out time, and loop momentum index.\nThe loop basis is also obtained for all the graphs.\n\nArguments:\n\nleaf_maps: A vector of the dictionary mapping the leaf value's index to the Graph of this leaf.               Each dict corresponds to a graph partition, such as (order, Gorder, Vorder).\nmaxloopNum: The maximum loop-momentum number.\n\nReturns\n\nA tuple of vectors containing information about the leaves of graphs, including their initial values, types, orders, input and output time indexes, and loop-momenta indexes.\nLoop-momentum basis (::Vector{Vector{Float64}}) for all the graphs.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.leafstates-Union{Tuple{G}, Tuple{Array{Dict{Int64, G}, 1}, LabelProduct}} where G<:Union{FeynmanGraph, Graph}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.leafstates","text":"function leafstates(leaf_maps::Vector{Dict{Int,G}}, labelProd::LabelProduct) where {G<:Union{Graph,FeynmanGraph}}\n\nExtracts leaf information from the leaf mapping from the leaf value's index to the leaf node for all graph partitions\nand their associated LabelProduct data (`labelProd`). \nThe information includes their initial value, type, orders, in/out time, and loop momenta.\n\nArguments:\n\nleaf_maps: A vector of the dictionary mapping the leaf value's index to the FeynmanGraph/Graph of this leaf.               Each dict corresponds to a graph partition, such as (order, Gorder, Vorder).\nlabelProd: A LabelProduct used to label the leaves of graphs.\n\nReturns\n\nA tuple of vectors containing information about the leaves of graphs, including their initial values, types, orders, input and output time indexes, and loop-momenta indexes.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.linear_to_index-Union{Tuple{N}, Tuple{LT}, Tuple{LabelProduct{LT, N}, Int64}} where {LT, N}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.linear_to_index","text":"function linear_to_index(obj::LabelProduct, I::Int)\n\nConvert the single linear index of the LabelProduct to a tuple of indexes of each label. \n\nArgument:\n\n'obj': The LabelProduct object\n'I': The linear index of the LabelProduct \n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.reconstruct-Tuple{FeynmanDiagram.FrontEnds.DiagramId, Vararg{Pair{Symbol}}}","page":"Front-end generates Feynman diagrams and translates then into a computational graph","title":"FeynmanDiagram.FrontEnds.reconstruct","text":"reconstruct(instance::DiagramId, updates::Pair{Symbol}...)\n\nCreate a new instance of the same type as instance, with specified fields updated to new values.\n\nUsage\n\nnewinstance = reconstruct(oldinstance, :field1 => newvalue1, :field2 => newvalue2)\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Parquet-Algorithm-to-Build-Diagrams","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"","category":"section"},{"location":"lib/parquet/#API","page":"Parquet Algorithm to Build Diagrams","title":"API","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"Modules = [FeynmanDiagram.Parquet]","category":"page"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.ParquetBlocks","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.ParquetBlocks","text":"struct ParquetBlocks\n\nThe channels of the left and right sub-vertex4 of a bubble diagram in the parquet equation\n\nMembers\n\nphi   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles\nppi   : channels of left sub-vertex for the particle-particle bubble\nΓ4   : channels of right sub-vertex of all channels\n\n\n\n\n\n","category":"type"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.ep_coupling-Tuple{FeynmanDiagram.FrontEnds.Parquet.DiagPara}","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.ep_coupling","text":"function ep_coupling(para::DiagPara;\n    extK=[getK(para.totalLoopNum, 1), getK(para.totalLoopNum, 2), getK(para.totalLoopNum, 3)],\n    channels::AbstractVector=[PHr, PHEr, PPr, Alli],\n    subdiagram=false,\n    name=:none, resetuid=false,\n    blocks::ParquetBlocks=ParquetBlocks()\n)\n\nGenerate electron-phonon 4-vertex diagrams using Parquet Algorithm. The right incoming Tau will be set to the last Tau for all diagrams |         | Γ3 –––-| |         |\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nchannels        : vector of channels in the left Γ3 diagrams. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.get_ver4I-Tuple{}","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.get_ver4I","text":"get_ver4I()\n\nRetrieves the global dictionary `vertex4I_diags` that contains graph initialized by `initialize_vertex4I_diags`. \nThis function is a getter that provides access to the stored graph data of the 3- and 4-point fully-irreducible (Alli) vertex functions.\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.green","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.green","text":"green(para::DiagPara, extK = getK(para.totalLoopNum, 1), extT = para.hasTau ? (1, 2) : (0, 0), subdiagram = false;\n    name = :G, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild composite Green's function. By definition, para.firstTauIdx is the first Tau index of the left most self-energy subdiagram.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nextT: [Tau index of the left leg, Tau index of the right leg]\nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA Graph object or nothing if the Green's function is illegal. \n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.initialize_vertex4I_diags-Tuple{}","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.initialize_vertex4I_diags","text":"initialize_vertex4I_diags(; filter=[NoHartree], spinPolarPara::Float64=0.0)\n\nInitialize the vertex4I_diags dictionary with the diagrams of the 3- and 4-point fully-irreducible (Alli) vertex functions.\n\nParameters\n\nfilter (optional) : a list of filter conditions to select the diagrams. Default is [NoHartree].\nspinPolarPara (optional) : the spin-polarization parameter. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.innerTauNum-Tuple{FeynmanDiagram.FrontEnds.Parquet.DiagramType, Any, Any}","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.innerTauNum","text":"function innerTauNum(type::DiagramType, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.mergeby","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.mergeby","text":"function mergeby(df::DataFrame, fields=Vector{Symbol}();\n    operator=Sum(), name::Symbol=:none,\n    getid::Function=g -> GenericId(g[1, :diagram].properties.para, Tuple(g[1, fields]))\n)\n\nAggregates and merges rows in a DataFrame based on specified fields and an aggregation operator. It is designed to work with data frames containing diagram representations or similar structured data,  allowing for flexible aggregation based on custom identifiers and properties.\n\nParameters\n\ndf: A DataFrame to be processed. It must contain a column named :diagram which holds Graph.\nfields: A vector of Symbols specifying the columns based on which the aggregation groups are formed.\noperator: The aggregation operator to be applied. This operator is used to aggregate data across rows within each group formed by the specified fields. The default is Sum().\nname: An optional Symbol representing the name of a new column to store the aggregated results. The default is :none.\ngetid: A function that generates a unique identifier for each group based on the specified fields and the properties of the :diagram column. The default function is g -> GenericId(g[1, :diagram].properties.para, Tuple(g[1, fields])).\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.polarization","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.polarization","text":"function polarization(para::DiagPara, extK=getK(para.totalLoopNum, 1), subdiagram=false; name=:Π, resetuid=false, blocks::ParquetBlocks=ParquetBlocks())\n\nGenerate polarization diagrams using Parquet Algorithm.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :diagram, :hash. \nAll polarization share the same external Tau index. With imaginary-time variables, they are extT = (para.firstTauIdx, para.firstTauIdx+1)\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.sigma","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.sigma","text":"function sigma(para::DiagPara, extK=getK(para.totalLoopNum, 1), subdiagram=false;\n    name=:Σ, resetuid=false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild sigma diagram.  When sigma is created as a subdiagram, then no Fock diagram is generated if para.filter contains NoFock, and no sigma diagram is generated if para.filter contains Girreducible\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :type, :extT, :diagram, :hash\nAll sigma share the same incoming Tau index, but not the outgoing one\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.update_extKT","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.update_extKT","text":"update_extKT(diags::Vector{Graph}, para::DiagPara, legK::Vector{Vector{Float64}}) -> Vector{Graph}\n\nReturns a new vector of graphs with updated external momenta (extK) and external times (extT),  based on the provided graphs, parameters, and external legs' momenta.\n\nArguments\n\ndiags::Vector{Graph}: A vector of Graph objects.\npara::DiagPara: parameters reconstructed in the graphs. Its firstTauIdx will update the extT of graphs.\nlegK::Vector{Vector{Float64}}: basis of the external momenta for the legs of the diagram as [left in, left out, right in, right out]. \nextraLoopIdx: the index of the extra loop in the external momenta basis in legK. Defaults to nothing, which means no extra loop is included. \n\nReturns\n\nVector{Graph}: A new vector of Graph objects with updated extK, extT, and para (if existing) properties for each node.\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.update_extKT!","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.update_extKT!","text":"update_extKT!(diags::Vector{Graph}, para::DiagPara, legK::Vector{Vector{Float64}})\n\nUpdate the external momenta (extK) and external times (extT) of all the nodes in a vector of graphs in-place.\n\nArguments\n\ndiags::Vector{Graph}: A vector of Graph objects.\npara::DiagPara: parameters reconstructed in the graphs. Its firstTauIdx will update the extT of graphs.\nlegK::Vector{Vector{Float64}}: basis of the external momenta for the legs of the diagram as [left in, left out, right in, right out].\nextraLoopIdx: the index of the extra loop in the external momenta basis in legK. Defaults to nothing, which means no extra loop is included. \n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.vertex3","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.vertex3","text":"function vertex3(para::DiagPara, _extK=[getK(para.totalLoopNum, 1), getK(para.totalLoopNum, 2)], subdiagram=false;\n    name=:Γ3, channels=[PHr, PHEr, PPr, Alli], resetuid=false, blocks::ParquetBlocks=ParquetBlocks())\n\nGenerate 3-vertex diagrams using Parquet Algorithm. With imaginary-time variables, all vertex3 generated has the same bosonic Tidx extT1=parafirstTauIdx and the incoming fermionic Tidx extT2=parafirstTauIdx+1.\n\n#Arguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [bosonic leg (out), fermionic in, fermionic out], extK[1] = extK[2] - extK[3]. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nchannels            : vector of channels of the current 4-vertex. \nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#FeynmanDiagram.FrontEnds.Parquet.vertex4","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.FrontEnds.Parquet.vertex4","text":"vertex4(para::DiagPara,\n    extK = [getK(para.totalLoopNum, 1), getK(para.totalLoopNum, 2), getK(para.totalLoopNum, 3)],\n    subdiagram = false;\n    channels::AbstractVector = [PHr, PHEr, PPr, Alli],\n    level = 1, name = :none, resetuid = false,\n    blocks::ParquetBlocks=ParquetBlocks(),\n    blockstoplevel::ParquetBlocks=blocks\n    )\n\nGenerate 4-vertex diagrams using Parquet Algorithm\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nsubdiagram      : a sub-vertex or not\nchannels            : vector of channels of the current 4-vertex. \nname            : name of the vertex\nlevel           : level in the diagram tree\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\nblockstoplevel  : building blocks of the Parquet equation at the toplevel. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"function"},{"location":"lib/parquet/#Parameters.reconstruct-Tuple{Type{FeynmanDiagram.FrontEnds.Parquet.DiagPara}, FeynmanDiagram.FrontEnds.Parquet.DiagPara, Any}","page":"Parquet Algorithm to Build Diagrams","title":"Parameters.reconstruct","text":"Parameters.reconstruct(p::DiagPara; kws...)\n\nType-stable version of the Parameters.reconstruct\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Usage","page":"Parquet Algorithm to Build Diagrams","title":"Usage","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"using FeynmanDiagram\npara = DiagPara(type = Ver4Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex4(para)\n\npara = DiagPara(type = Ver3Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex3(para)\n\npara = DiagPara(type = SigmaDiag, innerLoopNum = 1, hasTau = true);\nParquet.sigma(para)\n\npara = DiagPara(type = PolarDiag, innerLoopNum = 1, hasTau = true);\nParquet.polarization(para)","category":"page"},{"location":"lib/computgraph/#Computational-graph-for-general-feynman-diagrams","page":"Computational graph for general feynman diagrams","title":"Computational graph for general feynman diagrams","text":"","category":"section"},{"location":"lib/computgraph/#API","page":"Computational graph for general feynman diagrams","title":"API","text":"","category":"section"},{"location":"lib/computgraph/","page":"Computational graph for general feynman diagrams","title":"Computational graph for general feynman diagrams","text":"Modules = [FeynmanDiagram.ComputationalGraphs]","category":"page"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.FeynmanGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.FeynmanGraph","text":"mutable struct FeynmanGraph{F<:Number,W}\n\nComputational graph representation of a (collection of) Feynman diagram(s). All Feynman diagrams should share the same set of external and internal vertices.\n\nMembers:\n\nid::Int  the unique hash id to identify the diagram\nname::Symbol  name of the diagram\norders::Vector{Int}  orders associated with the Feynman graph, e.g., loop/derivative orders\nproperties::FeynmanProperties  diagrammatic properties, e.g., the operator vertices and topology\nsubgraphs::Vector{FeynmanGraph{F,W}}  vector of sub-diagrams \nsubgraph_factors::Vector{F}  scalar multiplicative factors associated with each subdiagram\noperator::DataType  node operation (Sum, Prod, etc.)\nweight::W  weight of the diagram\n\nExample:\n\njulia> g1 = FeynmanGraph([]; vertices=[𝑓⁺(1),𝑓⁻(2)], external_indices=[1,2], external_legs=[true,true])\n1:f⁺(1)|f⁻(2)=0.0\n\njulia> g2 = FeynmanGraph([]; vertices=[𝑓⁺(3),𝑓⁻(4)], external_indices=[1,2], external_legs=[true,true])\n2:f⁺(3)|f⁻(4)=0.0\n\njulia> g = FeynmanGraph([g1,g2]; vertices=[𝑓⁺(1),𝑓⁻(2),𝑓⁺(3),𝑓⁻(4)], operator=ComputationalGraphs.Prod(), external_indices=[1,2,3,4], external_legs=[true,true,true,true])\n3:f⁺(1)|f⁻(2)|f⁺(3)|f⁻(4)=0.0=Ⓧ (1,2)\n\n\n\n\n\n","category":"type"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.Graph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.Graph","text":"mutable struct Graph{F<:Number,W}\n\nA representation of a computational graph, e.g., an expression tree, with type stable node data.\n\nMembers:\n\nid::Int  the unique hash id to identify the diagram\nname::Symbol  name of the diagram\norders::Vector{Int}  orders associated with the graph, e.g., derivative orders\nsubgraphs::Vector{Graph{F,W}}  vector of sub-diagrams \nsubgraph_factors::Vector{F}  scalar multiplicative factors associated with each subgraph. Note that the subgraph factors may be manipulated algebraically. To associate a fixed multiplicative factor with this graph which carries some semantic meaning, use the factor argument instead.\noperator::DataType  node operation. Addition and multiplication are natively supported via operators Sum and Prod, respectively. Should be a concrete subtype of AbstractOperator.\nweight::W  the weight of this node\nproperties::Any extra information of Green's functions.\n\nExample:\n\njulia> g1 = Graph([])\n1=0.0\n\njulia> g2 = Graph([]; factor=2)\n2⋅2.0=0.0\n\njulia> g = Graph([g1, g2]; operator=ComputationalGraphs.Sum())\n3=0.0=⨁ (1,2)\n\n\n\n\n\n","category":"type"},{"location":"lib/computgraph/#Base.:*-Union{Tuple{W}, Tuple{F}, Tuple{Any, FeynmanGraph{F, W}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:*","text":"function Base.:*(c1, g2::Graph{F,W}) where {F,W}\n\nReturns a graph representing the scalar multiplication c1*g2.\n\nArguments:\n\nc1  scalar multiple\ng2  Feynman graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:*-Union{Tuple{W}, Tuple{F}, Tuple{Any, Graph{F, W}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:*","text":"function Base.:*(c1, g2::Graph{F,W}) where {F,W}\n\nReturns a graph representing the scalar multiplication c1*g2.\n\nArguments:\n\nc1  scalar multiple\ng2  computational graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:*-Union{Tuple{W}, Tuple{F}, Tuple{FeynmanGraph{F, W}, Any}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:*","text":"function Base.:*(g1::Graph{F,W}, c2) where {F,W}\n\nReturns a graph representing the scalar multiplication g1*c2.\n\nArguments:\n\ng1  Feynman graph\nc2  scalar multiple\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:*-Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Any}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:*","text":"function Base.:*(g1::Graph{F,W}, c2) where {F,W}\n\nReturns a graph representing the scalar multiplication g1*c2.\n\nArguments:\n\ng1  computational graph\nc2  scalar multiple\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:*-Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Graph{F, W}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:*","text":"function Base.:*(g1::Graph{F,W}, g2::Graph{F,W}) where {F,W}\n\nReturns a graph g1 * g2 representing the graph product between g1 and g2.\n\nArguments:\n\ng1  first computational graph\ng2  second computational graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:+-Union{Tuple{W}, Tuple{F}, Tuple{FeynmanGraph{F, W}, FeynmanGraph{F, W}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:+","text":"function Base.:+(g1::Graph{F,W}, g2::Graph{F,W}) where {F,W}\n\nReturns a graph g1 + g2 representing the addition of two Feynman diagrams g2 with g1. Diagrams g1 and g2 must have the same diagram type, orders, and external vertices.\n\nArguments:\n\ng1  first Feynman graph\ng2  second Feynman graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:+-Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Graph{F, W}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:+","text":"function Base.:+(g1::Graph{F,W}, g2::Graph{F,W}) where {F,W}\n\nReturns a graph g1 + g2 representing the addition of g2 with g1. Graphs g1 and g2 must have the same orders.\n\nArguments:\n\ng1  first computational graph\ng2  second computational graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:--Union{Tuple{W}, Tuple{F}, Tuple{FeynmanGraph{F, W}, FeynmanGraph{F, W}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:-","text":"function Base.:-(g1::Graph{F,W}, g2::Graph{F,W}) where {F,W}\n\nReturns a graph g1 - g2 representing the subtraction of g2 from g1. Diagrams g1 and g2 must have the same diagram type, orders, and external vertices.\n\nArguments:\n\ng1  first Feynman graph\ng2  second Feynman graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.:--Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Graph{F, W}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"Base.:-","text":"function Base.:-(g1::Graph{F,W}, g2::Graph{F,W}) where {F,W}\n\nReturns a graph g1 - g2 representing the subtraction of g2 from g1. Graphs g1 and g2 must have the same orders.\n\nArguments:\n\ng1  first computational graph\ng2  second computational graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.convert-Union{Tuple{G}, Tuple{W}, Tuple{F}, Tuple{Type{G}, FeynmanGraph{F, W}}} where {F, W, G<:Graph}","page":"Computational graph for general feynman diagrams","title":"Base.convert","text":"function Base.convert(::Type{G}, g::FeynmanGraph{F,W}) where {F,W,G<:Graph}\n\nConverts a FeynmanGraph `g` into a Graph, discarding its Feynman properties.\nAfter conversion, graph `g` is no longer guaranteed to be a valid (group of) Feynman diagram(s).\n\n# Arguments:\n- `g`  computational graph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.print-Tuple{IO, AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"Base.print","text":"print(io::IO, graph::AbstractGraph)\n\nWrite an un-decorated text representation of an AbstractGraph `graph` to the output stream `io`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#Base.show-Tuple{IO, AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"Base.show","text":"show(io::IO, graph::AbstractGraph; kwargs...)\n\nWrite a text representation of an AbstractGraph `graph` to the output stream `io`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.alleq-Tuple{Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.alleq","text":"Checks that all elements of an iterable x are equal.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.build_derivative_graph-Union{Tuple{N}, Tuple{G}, Tuple{AbstractVector{G}, NTuple{N, Int64}}} where {G<:Graph, N}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.build_derivative_graph","text":"function build_derivative_graph(graphs::AbstractVector{G}, orders::NTuple{N,Int};\n    nodes_id=nothing) where {G<:Graph,N}\n\nConstructs a derivative graph using forward automatic differentiation with given graphs and derivative orders.\n\nArguments:\n\ngraphs: A vector of graphs.\norders::NTuple{N,Int}: A tuple indicating the orders of differentiation. N represents the number of independent variables to be differentiated.\nnodes_id: Optional node IDs to indicate saving their derivative graph.\n\nReturns:\n\nA dictionary containing the dual derivative graphs for all indicated nodes. \n\nIf isnothing(nodes_id), indicated nodes include all leaf and root nodes. Otherwise, indicated nodes include all root nodes and other nodes from nodes_id.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.burn_from_targetleaves!-Union{Tuple{G}, Tuple{AbstractVector{G}, AbstractVector{Int64}}} where G<:AbstractGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.burn_from_targetleaves!","text":"function burn_from_targetleaves!(graphs::AbstractVector{G}, targetleaves_id::AbstractVector{Int}; verbose=0) where {G <: AbstractGraph}\n\nRemoves all nodes connected to the target leaves in-place via \"Prod\" operators.\n\nArguments:\n\ngraphs: A vector of graphs.\ntargetleaves_id::AbstractVector{Int}: Vector of target leafs' id.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nThe id of a constant graph with a zero factor if any graph in graphs was completely burnt; otherwise, nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.collect_labels-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.collect_labels","text":"function collect_labels(g::FeynmanGraph)\n\nReturns the list of sorted unique labels in graph `g`.\n\nArguments:\n\ng::FeynmanGraph: graph to find labels for\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.constant_graph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.constant_graph","text":"function constant_graph(factor=one(_dtype.factor))\n\nReturns a graph that represents a constant equal to f, where f is the factor with default value 1.\n\nArguments:\n\nf:  constant factor\n\n\n\n\n\n","category":"function"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.count_expanded_operation-Tuple{G} where G<:AbstractGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.count_expanded_operation","text":"function count_expanded_operation(g::G) where {G<:AbstractGraph}\n\nReturns the total number of operations in the totally expanded version (without any parentheses in the mathematical expression) of the graph.\n\nArguments:\n\ng::Graph: graph for which to find the total number of operations in its expanded version.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.count_leaves-Tuple{G} where G<:AbstractGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.count_leaves","text":"function count_leaves(g::G) where {G<:AbstractGraph}\n\nReturns the total number of leaves with unique id in the graph.\n\nArguments:\n\ng::Graph: graph for which to find the total number of leaves.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.count_operation-Tuple{G} where G<:AbstractGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.count_operation","text":"function count_operation(g::G) where {G<:AbstractGraph}\n\nReturns the total number of  additions and multiplications in the graph.\n\nArguments:\n\ng::Graph: graph for which to find the total number of  operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.diagram_type-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.diagram_type","text":"function diagram_type(g::FeynmanGraph)\n\nReturns the diagram type (::DiagramType) of FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.disconnect_subgraphs!-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.disconnect_subgraphs!","text":"function disconnect_subgraphs!(g::G) where {G<:AbstractGraph}\n\nEmpty the subgraphs and subgraph_factors of graph `g`. Any child nodes of g\nnot referenced elsewhere in the full computational graph are effectively deleted.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.drop_topology-Tuple{FeynmanProperties}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.drop_topology","text":"function drop_topology(p::FeynmanProperties)\n\nReturns a copy of the given FeynmanProperties `p` modified to have no topology.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.eldest-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.eldest","text":"function eldest(g::AbstractGraph)\n\nReturns the first child (subgraph) of a graph g.\n\nArguments:\n\ng::AbstractGraph: graph for which to find the first child\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external_indices-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external_indices","text":"function external_indices(g::FeynmanGraph)\n\nReturns a list of indices (::Vector{Int}}) to the external vertices of the FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external_labels-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external_labels","text":"function external_labels(g::FeynmanGraph)\n\nReturns the labels of all physical external vertices of FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external_legs-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external_legs","text":"function external_legs(g::FeynmanGraph)\n\nReturns a list of Boolean indices external_legs (::Vector{Bool}) indicating which external vertices of FeynmanGraph g have real legs (true: real leg, false: fake leg).\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external_operators-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external_operators","text":"function external_operators(g::FeynmanGraph)\n\nReturns all physical external operators (::OperatorProduct}) of FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external_vertex-Tuple{OperatorProduct}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external_vertex","text":"function external_vertex(ops::OperatorProduct;\n    name=\"\", factor=one(_dtype.factor), weight=zero(_dtype.weight), operator=Sum())\n\nCreate a ExternalVertex-type FeynmanGraph from given OperatorProduct ops, including several quantum operators for an purely external vertex.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.feynman_diagram-Union{Tuple{W}, Tuple{F}, Tuple{Array{FeynmanGraph{F, W}, 1}, Vector{Vector{Int64}}}, Tuple{Array{FeynmanGraph{F, W}, 1}, Vector{Vector{Int64}}, Union{Nothing, Vector{Int64}}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.feynman_diagram","text":"function feynman_diagram(subgraphs::Vector{FeynmanGraph{F,W}}, topology::Vector{Vector{Int}}, perm_noleg::Union{Vector{Int},Nothing}=nothing;\n    factor=one(_dtype.factor), weight=zero(_dtype.weight), name=\"\", diagtype::DiagramType=GenericDiag()) where {F,W}\n\nCreate a FeynmanGraph representing feynman diagram from all subgraphs and topology (connections between vertices), where each ExternalVertex is given in vertices,  while internal vertices are constructed with external legs of graphs in vertices, or simply OperatorProduct in vertices.\n\nArguments:\n\nsubgraphs::Vector{FeynmanGraph{F,W}} all subgraphs of the diagram. All external operators of subgraphs constitute all operators of the new diagram.\ntopology::Vector{Vector{Int}} topology of the diagram. Each Vector{Int} stores operators' index connected with each other (as a propagator). \nperm_noleg::Union{Vector{Int},Nothing}=nothing permutation of all the nonleg external operators. By default, setting nothing means to use the default order from subgraphs.\nfactor::F  overall scalar multiplicative factor for this diagram (e.g., permutation sign)\nweight  weight of the diagram\nname  name of the diagram\ndiagtype  type of the diagram\n\nExample:\n\njulia> V = [𝑓⁺(1)𝑓⁻(2)𝜙(3), 𝑓⁺(4)𝑓⁻(5)𝜙(6), 𝑓⁺(7)𝑓⁻(8)𝜙(9)];\njulia> g = feynman_diagram(interaction.(V), [[1, 5], [3, 9], [4, 8]], [3, 1, 2])\n7:f⁺(1)f⁻(2)ϕ(3)|f⁺(4)f⁻(5)ϕ(6)|f⁺(7)f⁻(8)ϕ(9)=0.0=Ⓧ (1,2,3,4,5,6)\n\njulia> g.subgraphs\n6-element Vector{FeynmanGraph{Float64, Float64}}:\n 1:f⁺(1)f⁻(2)ϕ(3)=0.0\n 2:f⁺(4)f⁻(5)ϕ(6)=0.0\n 3:f⁺(7)f⁻(8)ϕ(9)=0.0\n 4:f⁺(1)|f⁻(5)⋅-1.0=0.0\n 5:ϕ(3)|ϕ(9)=0.0\n 6:f⁺(4)|f⁻(8)⋅-1.0=0.0\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.flatten_all_chains!-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.flatten_all_chains!","text":"function flatten_all_chains!(g::AbstractGraph; verbose=0)\n\nF     Flattens all nodes representing trivial unary chains in-place in the given graph g. \n\nArguments:\n\ngraphs: The graph to be processed.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nThe mutated graph g with all chains flattened.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.flatten_all_chains!-Tuple{Union{Tuple, AbstractVector{<:AbstractGraph}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.flatten_all_chains!","text":"function flatten_all_chains!(graphs::Union{Tuple,AbstractVector{<:AbstractGraph}}; verbose=0)\n\nFlattens all nodes representing trivial unary chains in-place in the given graphs.\n\nArguments:\n\ngraphs: A collection of graphs to be processed.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nThe mutated collection graphs with all chains in each graph flattened.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.flatten_chains!-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.flatten_chains!","text":"function flatten_chains!(g::AbstractGraph)\n\nRecursively flattens chains of subgraphs within the given graph `g` by merging certain trivial unary subgraphs \ninto their parent graphs in the in-place form.\n\nActs only on subgraphs of `g` with the following structure: 𝓞 --- 𝓞' --- ⋯ --- 𝓞'' ⋯ (!),\nwhere the stop-case (!) represents a leaf, a non-trivial unary operator 𝓞'''(g) != g, or a non-unary operation.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.flatten_chains-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.flatten_chains","text":"function flatten_chains(g::AbstractGraph) \n\nRecursively flattens chains of subgraphs within a given graph `g` by merging certain trivial unary subgraphs into their parent graphs,\nThis function returns a new graph with flatten chains, derived from the input graph `g` remaining unchanged.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.flatten_prod!-Tuple{G} where G<:AbstractGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.flatten_prod!","text":"flatten_prod!(graph::G; map::Dict{Int,G}=Dict{Int,G}()) where {G<:AbstractGraph}\n\nRecursively merge multi-product sub-branches within the given graph `g  by merging  product subgraphs \ninto their parent product graphs in the in-place form.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\nmap::Dict{Int,G}=Dict{Int,G}(): A dictionary that maps the id of an original node with its corresponding new node after transformation. \n\nIn recursive transform, nodes can be visited several times by different parents. This map keeps track of those visited, and reuse those transformed sub-branches instead of recreating them.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.flatten_sum!-Tuple{G} where G<:AbstractGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.flatten_sum!","text":"flatten_sum!(graph::G; map::Dict{Int,G}=Dict{Int,G}()) where {G<:AbstractGraph}\n\nRecursively merge multi-product sub-branches within the given graph `g  by merging  sum subgraphs \ninto their parent sum graphs in the in-place form.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\nmap::Dict{Int,G}=Dict{Int,G}(): A dictionary that maps the id of an original node with its corresponding new node after transformation. \n\nIn recursive transform, nodes can be visited several times by different parents. This map keeps track of those visited, and reuse those transformed sub-branches instead of recreating them.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.forwardAD-Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Int64}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.forwardAD","text":"function forwardAD(diag::Graph{F,W}, ID::Int) where {F,W}\n\nGiven a  graph G and an id of graph g, calculate the derivative d G / d g by forward propagation algorithm.\n\nArguments:\n\ndiag::Graph{F,W}:  Graph G to be differentiated\nID::Int: ID of the graph g  \n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.forwardAD_root!-Union{Tuple{AbstractVector{G}}, Tuple{N}, Tuple{G}, Tuple{AbstractVector{G}, Int64}, Tuple{AbstractVector{G}, Int64, Dict{Tuple{Int64, NTuple{N, Bool}}, G}}} where {G<:Graph, N}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.forwardAD_root!","text":"function forwardAD_root!(graphs::AbstractVector{G}, idx::Int=1,\n    dual::Dict{Tuple{Int,NTuple{N,Bool}},G}=Dict{Tuple{Int,Tuple{Bool}},G}()) where {G<:Graph,N}\n\nComputes the forward automatic differentiation (AD) of the given graphs beginning from the roots.\n\nArguments:\n\ngraphs: A vector of graphs.\nidx: Index for differentiation (default: 1).\ndual: A dictionary that holds the result of differentiation.\n\nReturns:\n\nThe dual dictionary populated with all differentiated graphs, including the intermediate AD.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.group-Union{Tuple{G}, Tuple{AbstractVector{G}, Vector{Int64}}} where G<:FeynmanGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.group","text":"function group(gv::AbstractVector{G}, indices::Vector{Int}) where {G<:FeynmanGraph}\n\nGroup the graphs in gv by the external operators at the indices indices. Return a dictionary of Vector{OperatorProduct} to GraphVector.\n\nExample\n\njulia> p1 = propagator(𝑓⁺(1)𝑓⁻(2));\n\njulia> p2 = propagator(𝑓⁺(1)𝑓⁻(3));\n\njulia> p3 = propagator(𝑓⁺(2)𝑓⁻(3));\n\njulia> gv = [p1, p2, p3];\n\njulia> ComputationalGraphs.group(gv, [1, 2])\nDict{Vector{OperatorProduct}, Vector{FeynmanGraph{Float64, Float64}}} with 3 entries:\n  [f⁻(2), f⁺(1)] => [1:f⁺(1)|f⁻(2)⋅-1.0=0.0]\n  [f⁻(3), f⁺(1)] => [2:f⁺(1)|f⁻(3)⋅-1.0=0.0]\n  [f⁻(3), f⁺(2)] => [3:f⁺(2)|f⁻(3)⋅-1.0=0.0]\n\njulia> ComputationalGraphs.group(gv, [1, ])\nDict{Vector{OperatorProduct}, Vector{FeynmanGraph{Float64, Float64}}} with 2 entries:\n  [f⁻(3)] => [2:f⁺(1)|f⁻(3)⋅-1.0=0.0, 3:f⁺(2)|f⁻(3)⋅-1.0=0.0]\n  [f⁻(2)] => [1:f⁺(1)|f⁻(2)⋅-1.0=0.0]\n\njulia> ComputationalGraphs.group(gv, [2, ])\nDict{Vector{OperatorProduct}, Vector{FeynmanGraph{Float64, Float64}}} with 2 entries:\n  [f⁺(2)] => [3:f⁺(2)|f⁻(3)⋅-1.0=0.0]\n  [f⁺(1)] => [1:f⁺(1)|f⁻(2)⋅-1.0=0.0, 2:f⁺(1)|f⁻(3)⋅-1.0=0.0]\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.has_zero_subfactors-Tuple{AbstractGraph, Type{⨁}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.has_zero_subfactors","text":"function has_zero_subfactors(g::AbstractGraph, operator_type::Type{<:AbstractOperator})\n\nDetermines whether the graph `g` has only zero-valued subgraph factors based on the specified operator type.\nThis function does not recurse through the subgraphs of `g`, so it only checks the immediate subgraph factors.\nIf `g` is a leaf (i.e., has no subgraphs), the function returns `false` by convention.\n\nThe behavior of the function depends on the operator type:\n- `Sum`: Checks if all subgraph factors are zero.\n- `Prod`: Checks if any subgraph factor is zero.\n- `Power{N}`: Checks if the first subgraph factor is zero.\n- Other `AbstractOperator`: Defaults to return `false`.\n\nArguments:\n\ng::AbstractGraph: graph to be analyzed\noperator: the operator used in graph g\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.haschildren-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.haschildren","text":"function haschildren(g::AbstractGraph)\n\nReturns whether the graph has any children (subgraphs).\n\nArguments:\n\ng::AbstractGraph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.id-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.id","text":"function id(g::AbstractGraph)\n\nReturns the unique hash id of computational graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.interaction-Tuple{OperatorProduct}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.interaction","text":"function interaction(ops::OperatorProduct; name=\"\", reorder::Union{Function,Nothing}=nothing,\n    factor=one(_dtype.factor), weight=zero(_dtype.weight), operator=Sum())\n\nCreate a Interaction-type FeynmanGraph from given OperatorProduct ops, including several quantum operators for a vertex. One can call a reorder function for the operators ordering.  \n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.is_external-Tuple{FeynmanGraph, Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.is_external","text":"function isexternaloperators(g::FeynmanGraph, i) \n\nCheck if i in the external indices of FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.is_internal-Tuple{FeynmanGraph, Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.is_internal","text":"function is_internal(g::FeynmanGraph, i)\n\nCheck if i in the internal indices of FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isapprox_one-Tuple{Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isapprox_one","text":"function isapprox_one(x)\n\nReturns true if x ≈ one(x).\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isassociative-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isassociative","text":"function isassociative(g::AbstractGraph)\n\nReturns true if the graph operation of node `g` is associative.\nOtherwise, returns false.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isbranch-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isbranch","text":"function isbranch(g::AbstractGraph)\n\nReturns whether the graph g is a branch-type (depth-1 and one-child) graph.\n\nArguments:\n\ng::AbstractGraph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.ischain-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.ischain","text":"function ischain(g::AbstractGraph)\n\nReturns whether the graph g is a chain-type graph (i.e., a unary string).\n\nArguments:\n\ng::AbstractGraph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isequiv-Tuple{AbstractGraph, AbstractGraph, Vararg{Any}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isequiv","text":"function isequiv(a::AbstractGraph, b::AbstractGraph, args...)\n\nDetermine whether graph `a` is equivalent to graph `b` without considering fields in `args`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isleaf-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isleaf","text":"function isleaf(g::AbstractGraph)\n\nReturns whether the graph g is a leaf (terminating tree node).\n\nArguments:\n\ng::AbstractGraph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.linear_combination-Union{Tuple{Array{FeynmanGraph{F, W}, 1}}, Tuple{W}, Tuple{F}, Tuple{Array{FeynmanGraph{F, W}, 1}, AbstractVector}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.linear_combination","text":"function linear_combination(graphs::Vector{FeynmanGraph{F,W}}, constants::AbstractVector=ones(F, length(graphs))) where {F,W}\n\nGiven a vector 𝐠 of graphs each with the same type and external/internal vertices and  an equally-sized vector 𝐜 of constants, returns a new graph representing the linear combination (𝐜 ⋅ 𝐠).  The function identifies unique graphs from the input graphs and sums their associated constants. All input Graphs must have the same diagram type, orders, and external vertices.\n\nArguments:\n\ngraphs  vector of input FeymanGraphs\nconstants  vector of scalar multiples (defaults to ones(F, length(graphs))).\n\nReturns:\n\nA new FeynmanGraph{F,W} object representing the linear combination of the unique input graphs weighted by the constants, \n\nwhere duplicate graphs in the input graphs are combined by summing their associated constants. \n\nExample:\n\nGiven graphs `g1`, `g2`, `g1` and constants `c1`, `c2`, `c3`, the function computes `(c1+c3)*g1 + c2*g2`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.linear_combination-Union{Tuple{Array{Graph{F, W}, 1}}, Tuple{W}, Tuple{F}, Tuple{Array{Graph{F, W}, 1}, AbstractVector}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.linear_combination","text":"function linear_combination(graphs::Vector{Graph{F,W}}, constants::AbstractVector=ones(F, length(graphs))) where {F,W}\n\nGiven a vector 𝐠 of graphs and an equally-sized vector 𝐜 of constants, returns a new graph representing the linear combination (𝐜 ⋅ 𝐠).  The function identifies unique graphs from the input graphs and sums their associated constants. All input graphs must have the same orders.\n\nArguments:\n\ngraphs  vector of computational graphs\nconstants  vector of scalar multiples (defaults to ones(F, length(graphs))).\n\nReturns:\n\nA new Graph{F,W} object representing the linear combination of the unique input graphs weighted by the constants, \n\nwhere duplicate graphs in the input graphs are combined by summing their associated constants. \n\nExample:\n\nGiven graphs `g1`, `g2`, `g1` and constants `c1`, `c2`, `c3`, the function computes `(c1+c3)*g1 + c2*g2`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.linear_combination-Union{Tuple{W}, Tuple{F}, Tuple{FeynmanGraph{F, W}, FeynmanGraph{F, W}}, Tuple{FeynmanGraph{F, W}, FeynmanGraph{F, W}, Any}, Tuple{FeynmanGraph{F, W}, FeynmanGraph{F, W}, Any, Any}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.linear_combination","text":"function linear_combination(g1::FeynmanGraph{F,W}, g2::FeynmanGraph{F,W}, c1, c2) where {F,W}\n\nReturns a graph representing the linear combination c1*g1 + c2*g2. If g1 == g2, it will return a graph representing (c1+c2)*g1 Feynman Graphs g1 and g2 must have the same diagram type, orders, and external vertices.\n\nArguments:\n\ng1  first Feynman graph\ng2  second Feynman graph\nc1:  first scalar multiple (defaults to 1).\nc2:  second scalar multiple (defaults to 1).\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.linear_combination-Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Graph{F, W}}, Tuple{Graph{F, W}, Graph{F, W}, Any}, Tuple{Graph{F, W}, Graph{F, W}, Any, Any}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.linear_combination","text":"function linear_combination(g1::Graph{F,W}, g2::Graph{F,W}, c1, c2) where {F,W}\n\nReturns a graph representing the linear combination c1*g1 + c2*g2. If g1 == g2, it will return a graph representing (c1+c2)*g1. Graphs g1 and g2 must have the same orders.\n\nArguments:\n\ng1  first computational graph\ng2  second computational graph\nc1  first scalar multiple\nc2  second scalar multiple\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.mask_zero_subgraph_factors-Union{Tuple{F}, Tuple{Type{⨁}, Vector{F}}} where F","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.mask_zero_subgraph_factors","text":"function mask_zero_subgraph_factors(operator::Type{<:AbstractOperator}, subg_fac::Vector{F}) where {F}\n\nReturns a list of indices that should be considered when performing the operation (e.g., Sum, Prod, Power), effectively masking out zero values as appropriate.\n\nThe behavior of the function depends on the operator type:\n- `Sum`: Returns all indices that are not equal to zero.\n- `Prod`: Returns the index of the first zero value, or all indices if none are found.\n- `Power`: Returns `[1]`, or error if the power is negative.\n- Other `AbstractOperator`: Defaults to return all indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_all_linear_combinations!-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_all_linear_combinations!","text":"function merge_all_linear_combinations!(g::AbstractGraph; verbose=0)\n\nMerges all nodes representing a linear combination of a non-unique list of subgraphs in-place in the given graph `g`.\n\nArguments:\n\ng: An AbstractGraph.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nOptimized graph.\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_all_linear_combinations!-Tuple{Union{Tuple, AbstractVector{<:AbstractGraph}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_all_linear_combinations!","text":"function merge_all_linear_combinations!(graphs::Union{Tuple,AbstractVector{<:AbstractGraph}}; verbose=0)\n\nMerges all nodes representing a linear combination of a non-unique list of subgraphs in-place in the given graphs.\n\nArguments:\n\ngraphs: A collection of graphs to be processed.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nOptimized graphs.\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_all_multi_products!-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_all_multi_products!","text":"function merge_all_multi_products!(g::Graph; verbose=0)\n\nMerges all nodes representing a multi product of a non-unique list of subgraphs in-place in the given graph `g`.\n\nArguments:\n\ng::Graph: A Graph.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nOptimized graph.\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_all_multi_products!-Tuple{Union{Tuple, AbstractVector{<:Graph}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_all_multi_products!","text":"function merge_all_multi_products!(graphs::Union{Tuple,AbstractVector{<:Graph}}; verbose=0)\n\nMerges all nodes representing a multi product of a non-unique list of subgraphs in-place in the given graphs.\n\nArguments:\n\ngraphs: A collection of graphs to be processed.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nOptimized graphs.\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_linear_combination!-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_linear_combination!","text":"function merge_linear_combination!(g::AbstractGraph)\n\nModifies a computational graph `g` by factorizing multiplicative prefactors, e.g.,\n3*g1 + 5*g2 + 7*g1 + 9*g2 ↦ 10*g1 + 14*g2 = linear_combination(g1, g2, 10, 14).\nReturns a linear combination of unique subgraphs and their total prefactors. \nDoes nothing if the graph `g` does not represent a Sum operation.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_linear_combination-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_linear_combination","text":"function merge_linear_combination(g::AbstractGraph)\n\nReturns a copy of computational graph `g` with multiplicative prefactors factorized,\ne.g., 3*g1 + 5*g2 + 7*g1 + 9*g2 ↦ 10*g1 + 14*g2 = linear_combination(g1, g2, 10, 14).\nReturns a linear combination of unique subgraphs and their total prefactors. \nDoes nothing if the graph `g` does not represent a Sum operation.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_multi_product!-Union{Tuple{Graph{F, W}}, Tuple{W}, Tuple{F}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_multi_product!","text":"function merge_multi_product!(g::Graph{F,W}) where {F,W}\n\nMerge multiple products within a computational graph `g` if they share the same operator (`Prod`).\nIf `g.operator == Prod`, this function will merge `N` identical subgraphs into a single subgraph with a power operator `Power(N)`. \nThe function ensures each unique subgraph is counted and merged appropriately, preserving any distinct subgraph_factors associated with them.\n\nArguments:\n\ng::Graph: graph to be modified\n\nReturns\n\nA merged computational graph with potentially fewer subgraphs if there were repeating subgraphs  with the Prod operator. If the input graph's operator isn't Prod, the function returns the input graph unchanged.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_multi_product-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_multi_product","text":"function merge_multi_product(g::Graph{F,W}) where {F,W}\n\nReturns a copy of computational graph `g` with multiple products merged if they share the same operator (`Prod`).\nIf `g.operator == Prod`, this function will merge `N` identical subgraphs into a single subgraph with a power operator `Power(N)`. \nThe function ensures each unique subgraph is counted and merged appropriately, preserving any distinct subgraph_factors associated with them.\n\nArguments:\n\ng::Graph: graph to be modified\n\nReturns\n\nA merged computational graph with potentially fewer subgraphs if there were repeating subgraphs  with the Prod operator. If the input graph's operator isn't Prod, the function returns the input graph unchanged.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.multi_product-Union{Tuple{Array{Graph{F, W}, 1}}, Tuple{W}, Tuple{F}, Tuple{Array{Graph{F, W}, 1}, AbstractVector}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.multi_product","text":"multi_product(graphs::Vector{Graph{F,W}}, constants::AbstractVector=ones(F, length(graphs))) where {F,W,C}\n\nConstruct a product graph from multiple input graphs, where each graph can be weighted by a constant.  For graphs that are repeated more than once, it adds a power operator to the subgraph to represent the repetition. Moreover, it optimizes any trivial unary operators in the resulting product graph.\n\nArguments:\n\ngraphs::Vector{Graph{F,W}}: A vector of input graphs to be multiplied.\nconstants::AbstractVector: A vector of scalar multiples. If not provided, it defaults to a vector of ones of the same length as graphs.\n\nReturns:\n\nA new product graph with the unique subgraphs (or powered versions thereof) and the associated constants as subgraph factors.\n\nExample:\n\nGiven graphs `g1`, `g2`, `g1` and constants `c1`, `c2`, `c3`, the function computes `(c1*c3)*(g1)^2 * c2*g2`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.multi_product-Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Graph{F, W}}, Tuple{Graph{F, W}, Graph{F, W}, Any}, Tuple{Graph{F, W}, Graph{F, W}, Any, Any}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.multi_product","text":"function multi_product(g1::Graph{F,W}, g2::Graph{F,W}, c1=F(1), c2=F(1)) where {F,W,C}\n\nReturns a graph representing the multi product c1*g1 * c2*g2. If g1 == g2, it will return a graph representing c1*c2 * (g1)^2 with Power(2) operator.\n\nArguments:\n\ng1:  first computational graph\ng2:  second computational graph\nc1:  first scalar multiple (defaults to 1).\nc2:  second scalar multiple (defaults to 1).\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.name-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.name","text":"function name(g::AbstractGraph)\n\nReturns the name of computational graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.onechild-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.onechild","text":"function onechild(g::AbstractGraph)\n\nReturns whether the graph g has only one child (subgraph).\n\nArguments:\n\ng::AbstractGraph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.open_parenthesis!-Tuple{G} where G<:AbstractGraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.open_parenthesis!","text":"open_parenthesis!(graph::G; map::Dict{Int,G}=Dict{Int,G}()) where {G<:AbstractGraph}\n\nRecursively open parenthesis of subgraphs within the given graph `g`with in place form.  The graph eventually becomes \na single Sum root node with multiple subgraphs that represents multi-product of nodes (not flattened).\n\nArguments:\n\ng::AbstractGraph: graph to be modified\nmap::Dict{Int,G}=Dict{Int,G}(): A dictionary that maps the id of an original node with its corresponding new node after transformation. \n\nIn recursive transform, nodes can be visited several times by different parents. This map keeps track of those visited, and reuse those transformed sub-branches instead of recreating them. parents\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.operator-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.operator","text":"function operator(g::AbstractGraph)\n\nReturns the operation associated with computational graph node `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.optimize!-Tuple{Union{Tuple, AbstractVector{<:AbstractGraph}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.optimize!","text":"function optimize!(graphs::Union{Tuple,AbstractVector{<:AbstractGraph}}; level=0, verbose=0, normalize=nothing)\n\nIn-place optimization of given `graphs`. Removes duplicated leaves, flattens chains, \nmerges linear combinations, and removes zero-valued subgraphs. When `level > 0`, also removes duplicated intermediate nodes.\n\nArguments:\n\ngraphs: A tuple or vector of graphs.\nlevel: Optimization level (default: 0). A value greater than 0 triggers more extensive but slower optimization processes, such as removing duplicated intermediate nodes.\nverbose: Level of verbosity (default: 0).\nnormalize: Optional function to normalize the graphs (default: nothing).\n\nReturns\n\nReturns the optimized graphs. If the input graphs is empty, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.optimize-Tuple{Union{Tuple, AbstractVector{<:AbstractGraph}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.optimize","text":"function optimize(graphs::Union{Tuple,AbstractVector{<:AbstractGraph}}; level=0, verbose=0, normalize=nothing)\n\nOptimizes a copy of given `graphs`. Removes duplicated nodes (when `level > 0`) or leaves, flattens chains, \nmerges linear combinations, and removing zero-valued subgraphs.\n\nArguments:\n\ngraphs: A tuple or vector of graphs.\nlevel: Optimization level (default: 0). A value greater than 0 triggers more extensive but slower optimization processes, such as removing duplicated nodes.\nverbose: Level of verbosity (default: 0).\nnormalize: Optional function to normalize the graphs (default: nothing).\n\nReturns:\n\nA tuple/vector of optimized graphs.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.orders-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.orders","text":"function orders(g::AbstractGraph)\n\nReturns the derivative orders (::Vector{Int}) of computational graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.plot_tree-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.plot_tree","text":"function plot_tree(graph::AbstractGraph; verbose = 0, maxdepth = 6)\n\nVisualize the computational graph as a tree using ete3 python package\n\n#Arguments\n\ngraph::AbstractGraph        : the computational graph struct to visualize\nverbose=0   : the amount of information to show\nmaxdepth=6  : deepest level of the computational graph to show\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.propagator-Tuple{Union{OperatorProduct, Vector{QuantumOperator}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.propagator","text":"function propagator(ops::Union{OperatorProduct,Vector{QuantumOperator}};\n    name=\"\", factor=one(_dtype.factor), weight=zero(_dtype.weight), operator=Sum())\n\nCreate a Propagator-type FeynmanGraph from given OperatorProduct or Vector{QuantumOperator} ops, including two quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.properties-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.properties","text":"function properties(g::AbstractGraph)\n\nReturns additional properties, if any, of the computational graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.relabel!-Tuple{FeynmanGraph, Dict{Int64, Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.relabel!","text":"function relabel!(g::FeynmanGraph, map::Dict{Int,Int})\n\nRelabels the quantum operators in `g` and its subgraphs according to `map`.\nFor example, `map = {1=>2, 3=>2}`` will find all quantum operators with labels 1 and 3, and then map them to 2.\n\nArguments:\n\ng::FeynmanGraph: graph to be modified\nmap: mapping from old labels to the new ones\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.relabel-Tuple{FeynmanGraph, Dict{Int64, Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.relabel","text":"function relabel(g::FeynmanGraph, map::Dict{Int,Int})\n\nReturns a copy of `g` with quantum operators in `g` and its subgraphs relabeled according to `map`.\nFor example, `map = {1=>2, 3=>2}` will find all quantum operators with labels 1 and 3, and then map them to 2.\n\nArguments:\n\ng::FeynmanGraph: graph to be modified\nmap: mapping from old labels to the new ones\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.remove_all_zero_valued_subgraphs!-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.remove_all_zero_valued_subgraphs!","text":"function remove_all_zero_valued_subgraphs!(g::AbstractGraph; verbose=0)\n\nRecursively removes all zero-valued subgraph(s) in-place in the given graph `g`.\n\nArguments:\n\ng: An AbstractGraph.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nOptimized graph.\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.remove_all_zero_valued_subgraphs!-Tuple{Union{Tuple, AbstractVector{<:AbstractGraph}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.remove_all_zero_valued_subgraphs!","text":"function remove_all_zero_valued_subgraphs!(graphs::Union{Tuple,AbstractVector{<:AbstractGraph}}; verbose=0)\n\nRecursively removes all zero-valued subgraph(s) in-place in the given graphs.\n\nArguments:\n\ngraphs: A collection of graphs to be processed.\nverbose: Level of verbosity (default: 0).\n\nReturns:\n\nOptimized graphs.\n\n\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.remove_duplicated_leaves!-Tuple{Union{Tuple, AbstractVector{<:AbstractGraph}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.remove_duplicated_leaves!","text":"function remove_duplicated_leaves!(graphs::Union{Tuple,AbstractVector{<:AbstractGraph}}; verbose=0, normalize=nothing, kwargs...)\n\nRemoves duplicated leaf nodes in-place from a collection of graphs. It also provides optional normalization for these leaves.\n\nArguments:\n\ngraphs: A collection of graphs to be processed.\nverbose: Level of verbosity (default: 0).\nnormalize: Optional function to normalize the graphs (default: nothing).\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.remove_zero_valued_subgraphs!-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.remove_zero_valued_subgraphs!","text":"function remove_zero_valued_subgraphs!(g::AbstractGraph)\n\nRemoves zero-valued (zero subgraph_factor) subgraph(s) of a computational graph `g`. If all subgraphs are zero-valued, the first one (`eldest(g)`) will be retained.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.remove_zero_valued_subgraphs-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.remove_zero_valued_subgraphs","text":"function remove_zero_valued_subgraphs(g::AbstractGraph)\n\nReturns a copy of graph `g` with zero-valued (zero subgraph_factor) subgraph(s) removed.\nIf all subgraphs are zero-valued, the first one (`eldest(g)`) will be retained.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.replace_subgraph!-Tuple{AbstractGraph, AbstractGraph, AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.replace_subgraph!","text":"function replace_subgraph!(g::AbstractGraph, w::AbstractGraph, m::AbstractGraph)\n\nModifies `g` by replacing the subgraph `w` with a new graph `m`.\nFor Feynman diagrams, subgraphs `w` and `m` should have the same diagram type, orders, and external indices.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\nw::AbstractGraph: subgraph to replace\nm::AbstractGraph: new subgraph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.replace_subgraph-Tuple{AbstractGraph, AbstractGraph, AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.replace_subgraph","text":"function replace_subgraph(g::AbstractGraph, w::AbstractGraph, m::AbstractGraph)\n\nCreates a modified copy of `g` by replacing the subgraph `w` with a new graph `m`.\nFor Feynman diagrams, subgraphs `w` and `m` should have the same diagram type, orders, and external indices.\n\nArguments:\n\ng::AbstractGraph: graph to be modified\nw::AbstractGraph: subgraph to replace\nm::AbstractGraph: new subgraph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_id!-Tuple{AbstractGraph, Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_id!","text":"function set_id!(g::AbstractGraph, id)\n\nUpdate the id of graph `g` to `id`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_name!-Tuple{AbstractGraph, AbstractString}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_name!","text":"function set_name!(g::AbstractGraph, name::AbstractString)\n\nUpdate the name of graph `g` to `name`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_operator!-Tuple{AbstractGraph, AbstractOperator}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_operator!","text":"function set_operator!(g::AbstractGraph, operator::AbstractOperator)\n\nUpdate the operator of graph `g` to `typeof(operator)`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_operator!-Tuple{AbstractGraph, Type{<:AbstractOperator}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_operator!","text":"function set_operator!(g::AbstractGraph, operator::Type{<:AbstractOperator})\n\nUpdate the operator of graph `g` to `operator`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_orders!-Tuple{AbstractGraph, AbstractVector}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_orders!","text":"function set_orders!(g::AbstractGraph, orders::AbstractVector)\n\nUpdate the orders of graph `g` to `orders`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_properties!-Tuple{AbstractGraph, Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_properties!","text":"function set_properties!(g::AbstractGraph, properties)\n\nUpdate the properties of graph `g` to `properties`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_subgraph!","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_subgraph!","text":"function set_subgraph!(g::AbstractGraph, subgraph::AbstractGraph, i=1)\n\nUpdate the `i`th subgraph of graph `g` to `subgraph`.\nDefaults to the first subgraph factor if an index `i` is not supplied.\n\n\n\n\n\n","category":"function"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_subgraph_factor!","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_subgraph_factor!","text":"function setsubgraphfactor!(g::AbstractGraph, subgraph_factor, i=1)\n\nUpdate the `i`th subgraph factor of graph `g` to `subgraph_factor`.\nDefaults to the first subgraph factor if an index `i` is not supplied.\n\n\n\n\n\n","category":"function"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_subgraph_factors!-Tuple{AbstractGraph, AbstractVector, AbstractVector{Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_subgraph_factors!","text":"function setsubgraphfactors!(g::AbstractGraph, subgraph_factors::AbstractVector, indices::AbstractVector{Int})\n\nUpdate the specified subgraph factors of graph `g` at indices `indices` to `subgraph_factors`.\nBy default, calls `set_subgraph_factor!(g, subgraph_factors[i], i)` for each `i` in `indices`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_subgraph_factors!-Tuple{AbstractGraph, AbstractVector}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_subgraph_factors!","text":"function setsubgraphfactors!(g::AbstractGraph, subgraph_factors::AbstractVector)\n\nUpdate the subgraph factors of graph `g` to `subgraphs`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_subgraphs!-Tuple{AbstractGraph, AbstractVector{<:AbstractGraph}, AbstractVector{Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_subgraphs!","text":"function set_subgraphs!(g::AbstractGraph, subgraphs::AbstractVector{<:AbstractGraph}, indices::AbstractVector{Int})\n\nUpdate the specified subgraphs of graph `g` at indices `indices` to `subgraphs`.\nBy default, calls `set_subgraph!(g, subgraphs[i], i)` for each `i` in `indices`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_subgraphs!-Tuple{AbstractGraph, AbstractVector{<:AbstractGraph}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_subgraphs!","text":"function set_subgraphs!(g::AbstractGraph, subgraphs::AbstractVector{<:AbstractGraph})\n\nUpdate the full list of subgraphs of graph `g` to `subgraphs`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.set_weight!-Tuple{AbstractGraph, Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.set_weight!","text":"function set_weight!(g::AbstractGraph, weight)\n\nUpdate the weight of graph `g` to `weight`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.standardize_labels!-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.standardize_labels!","text":"function standardize_labels!(g::FeynmanGraph)\n\nFinds all labels involved in `g` and its subgraphs and \nmodifies `g` by relabeling in standardized order, e.g.,\n(1, 4, 5, 7, ...) ↦ (1, 2, 3, 4, ....)\n\nArguments:\n\ng::FeynmanGraph: graph to be relabeled\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.standardize_labels-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.standardize_labels","text":"function standardize_labels!(g::FeynmanGraph)\n\nFinds all labels involved in `g` and its subgraphs and returns \na copy of `g` relabeled in a standardized order, e.g.,\n(1, 4, 5, 7, ...) ↦ (1, 2, 3, 4, ....)\n\nArguments:\n\ng::FeynmanGraph: graph to be relabeled\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.subgraph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.subgraph","text":"function subgraph(g::AbstractGraph, i=1)\n\nReturns a copy of the `i`th subgraph of computational graph `g`.\nDefaults to the first subgraph if an index `i` is not supplied.\n\n\n\n\n\n","category":"function"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.subgraph_factor","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.subgraph_factor","text":"function subgraph_factor(g::AbstractGraph, i=1)\n\nReturns a copy of the `i`th subgraph factor of computational graph `g`.\nDefaults to the first subgraph factor if an index `i` is not supplied.\n\n\n\n\n\n","category":"function"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.subgraph_factors-Tuple{AbstractGraph, AbstractVector{Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.subgraph_factors","text":"function subgraph_factors(g::AbstractGraph, indices::AbstractVector{Int})\n\nReturns the subgraph factors of computational graph `g` at indices `indices`.\nBy default, calls `subgraph_factor(g, i)` for each `i` in `indices`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.subgraph_factors-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.subgraph_factors","text":"function subgraph_factors(g::AbstractGraph)\n\nReturns the subgraph factors of computational graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.subgraphs-Tuple{AbstractGraph, AbstractVector{Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.subgraphs","text":"function subgraphs(g::AbstractGraph, indices::AbstractVector{Int})\n\nReturns the subgraphs of computational graph `g` at indices `indices`.\nBy default, calls `subgraph(g, i)` for each `i` in `indices`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.subgraphs-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.subgraphs","text":"function subgraphs(g::AbstractGraph)\n\nReturns the subgraphs of computational graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.topology-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.topology","text":"function topology(g::FeynmanGraph)\n\nReturns the topology (::Vector{Vector{Int}}) of FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.unary_istrivial-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.unary_istrivial","text":"function unary_istrivial(g::AbstractGraph)\n\nReturns true if the unary form of the graph operation of node `g` is trivial.\nOtherwise, returns false.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.unique_nodes!","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.unique_nodes!","text":"function unique_nodes!(graphs::AbstractVector{<:AbstractGraph})\n\nIdentifies and retrieves unique nodes from a set of graphs.\n\nArguments:\n\ngraphs: A collection of graphs to be processed.\n\nReturns:\n\nA mapping dictionary from the id of each leaf to the unique leaf node.\n\n\n\n\n\n","category":"function"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.vertex","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.vertex","text":"function vertex(g::FeynmanGraph, i=1)\n\nReturns the ith vertex (::OperatorProduct) of FeynmanGraph g. Defaults to the first vertex if an index i is not supplied.\n\n\n\n\n\n","category":"function"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.vertices-Tuple{FeynmanGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.vertices","text":"function vertices(g::FeynmanGraph)\n\nReturns all vertices (::Vector{OperatorProduct}) of FeynmanGraph g.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.weight-Tuple{AbstractGraph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.weight","text":"function weight(g::AbstractGraph)\n\nReturns the weight of the computational graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/utility/#API","page":"Utility","title":"API","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [FeynmanDiagram.Utility]","category":"page"},{"location":"lib/utility/#FeynmanDiagram.Utility.taylorAD-Union{Tuple{G}, Tuple{Vector{G}, Vector{Int64}, Vector{Function}}} where G<:Graph","page":"Utility","title":"FeynmanDiagram.Utility.taylorAD","text":"function taylorAD(graphs::Vector{G}, deriv_orders::Vector{Int}, leaf_dep_funcs::Vector{Function};\n    dict_graphs::Dict{Vector{Int},Vector{Graph}}=Dict{Vector{Int},Vector{Graph}}()\n) where {G<:Graph}\n\nPerforms Taylor-mode automatic differentiation (AD) on a vector of graphs, with the differentiation process tailored based on specified maximum orders of differentiation \nand leaf dependency functions. It categorizes the differentiated graphs in a dictionary based on their derivative orders.\n\nParameters\n\ngraphs: A vector of graphs to be differentiated.\nderiv_orders: A vector of integers specifying the maximum orders of differentiation to apply to the graphs.\nleaf_dep_funcs: A vector of functions determining the dependency of differentiation variables on the properties of leaves in the graphs. \ndict_graphs: Optional. A dictionary for storing the output graphs, keyed by vectors of integers representing the specific differentiation orders. Defaults to an empty dictionary.\n\nReturns\n\nDict{Vector{Int},Vector{Graph}}: A dictionary containing the graphs processed through Taylor-mode AD, categorized by their differentiation orders.\n\nExample Usage\n\n# Define a vector of graphs\ngraphs = [g1, g2]\n# Specify the maximum orders of differentiation\nderiv_orders = [2, 3, 3]\n\n# Define a vector of differentiation dependency functions for the properties of leaf. \n# The first and second functions specify identify `BareGreenId` and `BareInteractionId` properties as the Green's function and interaction counterterms, respectively.\n# The third function specifies the dependence of on the first external momentum of the leaf.\nleaf_dep_funcs = [pr -> pr isa FrontEnds.BareGreenId, pr -> pr isa FrontEnds.BareInteractionId, pr -> pr.extK[1] != 0]\n\n# Perform Taylor-mode AD and categorize the results. `result_dict` holds the AD results, organized by differentiation orders `[0:2, 0:3, 0:3]`.\nresult_dict = taylorAD(graphs, deriv_orders, leaf_dep_funcs)\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#FeynmanDiagram.Utility.taylorexpansion!-Union{Tuple{FeynmanGraph{F, W}}, Tuple{W}, Tuple{F}, Tuple{FeynmanGraph{F, W}, Dict{Int64, Vector{Bool}}}} where {F, W}","page":"Utility","title":"FeynmanDiagram.Utility.taylorexpansion!","text":"function taylorexpansion!(graph::FeynmanGraph{F,W}, var_dependence::Dict{Int,Vector{Bool}}=Dict{Int,Vector{Bool}}(); to_coeff_map::Dict{Int,TaylorSeries{G}}=Dict{Int,TaylorSeries{G}}()) where {F,W}\n\nReturn a taylor series of FeynmanGraph g, together with a map of between nodes of g and correponding taylor series.\n\nArguments:\n\ngraph  Target FeynmanGraph \nvar_dependence::Dict{Int,Vector{Bool}} A dictionary that specifies the variable dependence of target graph leaves. Should map the id of each leaf to a Bool vector.    The length of the vector should be the same as number of variables.\nto_coeff_map::Dict{Int,TaylorSeries} A dicitonary that maps id of each node of target graph to its correponding taylor series.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#FeynmanDiagram.Utility.taylorexpansion!-Union{Tuple{G}, Tuple{G, Dict{Int64, Vector{Bool}}}} where G<:Graph","page":"Utility","title":"FeynmanDiagram.Utility.taylorexpansion!","text":"function taylorexpansion!(graph::G, var_dependence::Dict{Int,Vector{Bool}}=Dict{Int,Vector{Bool}}(); to_coeff_map::Dict{Int,TaylorSeries{G}}=Dict{Int,TaylorSeries{G}}()) where {G<:Graph}\n\nReturn a taylor series of graph g, together with a map of between nodes of g and correponding taylor series.\n\nArguments:\n\ngraph  Target graph \nvar_dependence::Dict{Int,Vector{Bool}} A dictionary that specifies the variable dependence of target graph leaves. Should map the id of each leaf to a Bool vector.    The length of the vector should be the same as number of variables.\nto_coeff_map::Dict{Int,TaylorSeries} A dicitonary that maps id of each node of target graph to its correponding taylor series.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#FeynmanDiagram.Utility.taylorexpansion!-Union{Tuple{W}, Tuple{F}, Tuple{FeynmanGraph{F, W}, Tuple{Vector{Bool}, Vector{Bool}}}} where {F, W}","page":"Utility","title":"FeynmanDiagram.Utility.taylorexpansion!","text":"function taylorexpansion!(graph::FeynmanGraph{F,W}, propagator_var::Tuple{Vector{Bool},Vector{Bool}}, label::Tuple{LabelProduct,LabelProduct}; to_coeff_map::Dict{Int,TaylorSeries{Graph{F,W}}}=Dict{Int,TaylorSeries{Graph{F,W}}}()) where {F,W}\n\nReturn a taylor series of FeynmanGraph g, together with a map of between nodes of g and correponding taylor series. In this set up, the leaves that are the same type of propagators (fermi or bose) depend on the same set of variables, \nwhereas other types of Feynman diagrams (such as vertices) depends on no variables that need to be differentiated (for AD purpose, they are just constants).\n\nArguments:\n\ngraph  Target FeynmanGraph\npropagator_var::Tuple{Vector{Bool},Vector{Bool}} A Tuple that specifies the variable dependence of fermi (first element) and bose propagator (second element).   The dependence is given by a vector of the length same as the number of variables.\nlabel::Tuple{LabelProduct,LabelProduct} A Tuple fermi (first element) and bose LabelProduct (second element).\nto_coeff_map::Dict{Int,TaylorSeries} A dicitonary that maps id of each node of target diagram to its correponding taylor series.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#FeynmanDiagram.Utility.taylorexpansion!-Union{Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Dict{DataType, Vector{Bool}}}} where {F, W}","page":"Utility","title":"FeynmanDiagram.Utility.taylorexpansion!","text":"function taylorexpansion!(graph::Graph{F,W}, propagator_var::Dict{DataType,Vector{Bool}};\n    to_coeff_map::Dict{Int,TaylorSeries{Graph{F,W}}}=Dict{Int,TaylorSeries{Graph{F,W}}}()) where {F,W}\n    \nReturn a taylor series of Graph g, together with a map of between nodes of g and correponding taylor series. In this set up, the leaves that are the same type of diagrams (such as Green functions) depend on the same set of variables.\n\nArguments:\n\ngraph  Target Graph\npropagator_var::Dict{DataType,Vector{Bool}} A dictionary that specifies the variable dependence of different types of diagrams. Should be a map between DataTypes in DiagramID and Bool vectors.   The dependence is given by a vector of the length same as the number of variables.\nto_coeff_map::Dict{Int,TaylorSeries} A dicitonary that maps id of each node of target diagram to its correponding taylor series.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#FeynmanDiagram.Utility.taylorexpansion_withmap-Tuple{G} where G<:Graph","page":"Utility","title":"FeynmanDiagram.Utility.taylorexpansion_withmap","text":"taylorexpansion_withmap(g::G; coeffmode=true, var::Vector{Int}=collect(1:get_numvars())) where {G<:Graph}\n\nReturn a taylor series of graph g, together with a map of chain relationships between generated derivatives.\nThis function is only internally used for constructing high order derivatives by naive nested forward AD.\nIt is only for banch mark purpose and not exported.\n\nArguments:\n\ng  Target graph \ncoeffmode If true, the generated taylor series saves taylor coefficients with the factorial prefactor. If false, the taylor series saves derivatives instead\nvar The index of variables graph depends on\n\n\n\n\n\n","category":"method"},{"location":"manual/interaction/#Interaction/Scattering-Amplitude-Convention","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"In general, the interaction (or scattering amplitude) between two spin-12 particles only has two independent spin components. Here we briefly review some of the common conventions of the spin components in literature, and show how to map between different conventions.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We assume a particle from the left collides with a particle from the right. Due to the interaction between the two particles, one of them scatters to the left, and the other to the right. ","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We will use the index alphabetagammadelta to label the left incoming, the left outgoing, the right incoming and the right outgoing particles. We assume four legs associate with four momentum-frequency vectors k_1 k_2 k_3 k_4.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"There are two possible scatterings: a direct scattering where the two particles don't permutate after the collision, and an exchange scattering where the two particles permutate. Therefore, the total scattering amplitude has two contributions,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v_alphabetagammadelta(1234) = v^d_alphabetagammadelta(1234)+v^e_alphabetagammadelta(1234)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the exchange contribution is different from the direct counterpart up to an exchange of two outgoing legs and an overall particle statistic sign xi =pm 1,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^d_alphadeltagammabeta(1432)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where we have abbreviated the momentum-frequency vectors as indices.","category":"page"},{"location":"manual/interaction/#1.-Spin-symmetric-and-asymmetric-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"1. Spin symmetric and asymmetric convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"A interaction is split into a term that is independent of the spin (e.g., Coulomb interaction between electrons) and a term with spin dependence (e.g., ferromagnetic/antiferromagnetic interaction). This convention is commonly used in textbooks of Fermi liquid theory.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_alphabetagammadelta(1234) equiv v^s_1234delta_alphabetadelta_gammadelta + v^a_1234 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the superscript d means the scattering is direct.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, then one needs to exchange beta leftrightarrow gamma and other internal variables,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^s_1432delta_alphadeltadelta_gammabeta + xi v^a_1432 vecsigma_alphadeltacdot vecsigma_gammabeta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xifracv^s_1432+3v^a_14322delta_alphabetadelta_gammadelta + xi fracv^s_1432-v^a_14322 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"To derive the above equations, we use the identity vecsigma_alphabetacdot vecsigma_gammadelta=2 delta_alpha delta delta_beta gamma-delta_alpha beta delta_gamma delta, which gives the following equations,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"delta_alphadeltadelta_gammabeta=frac12delta_alphabetadelta_gammadelta+frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"and,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"vecsigma_alphadeltacdot vecsigma_gammabeta=frac32delta_alphabetadelta_gammadelta-frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/#2.-Spin-\\uparrow\\uparrow-and-\\uparrow\\downarrow-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"2. Spin uparrowuparrow and uparrowdownarrow convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"An alternative parameterization of the interaction matrix is by specifiying the spin components v_uparrowuparrow equiv v_uparrowuparrowuparrowuparrow and v_uparrowdownarrow equiv v_uparrowuparrowdownarrowdownarrow. They can be derived from v_s and v_a by the simple relation,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowuparrow(1234) = v^s_1234+v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowdownarrow(1234) = v^s_1234-v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, the exchange interaction v^e,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowuparrow(1234) = xifracv^s_1432+3v^a_14322+xifracv^s_1432-v^s_14322 = xi v^s_1432+ xi v^a_1432","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowdownarrow(1234) = xifracv^s_1432+3v^a_14322-xifracv^s_1432-v^s_14322 = 2 xi v^a_1432","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules","page":"Feynman Rules","title":"Feynman Rules","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"In general, we follow the convention in the textbook \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95,","category":"page"},{"location":"manual/feynman_rule/#Fourier-Transform","page":"Feynman Rules","title":"Fourier Transform","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G(tau) = frac1beta sum_n G(iomega_n) texte^-iomega_n tau","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G(iomega_n) = int_0^beta G(tau) texte^iomega_n tau dtau","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the Matsubara-frequency omega_n=2pi nbeta for boson and omega_n = 2pi (n+1)beta for fermion.","category":"page"},{"location":"manual/feynman_rule/#Action-and-Partition-Sum","page":"Feynman Rules","title":"Action and Partition Sum","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The partition sum associates with a generic action,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Z = int mathcalDbarpsimathcalDpsi expleft(-Sright)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the action takes a generic form,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"S = barpsi_1left(fracpartialpartial tau +epsilon_k right)psi_1 + V_1234barpsi_1barpsi_2psi_3psi_4","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where barpsi and psi are Grassman fields.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"In the Matsubara-frequency domain, the action is,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"S = barpsi_1left(-iomega_n +epsilon_k right)psi_1 + V_1234barpsi_1barpsi_2psi_3psi_4","category":"page"},{"location":"manual/feynman_rule/#Bare-Propagator","page":"Feynman Rules","title":"Bare Propagator","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Imaginary time","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"g(tau k) = leftmathcalT psi(k tau) barpsi(k 0) right_0= frace^-epsilon_k tau1+e^-epsilon_k betatheta(tau)+xi frace^-epsilon_k (beta+tau)1+e^-epsilon_k betatheta(-tau)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where xi is +1 for boson and -1 for fermion.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Matusbara frequency","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"g(iomega_n k) = -frac1iomega_n-epsilon_k","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Then the action takes a simple form,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"S = barpsi_1g_12^-1psi_2 + V_1234barpsi_1barpsi_2psi_3psi_4","category":"page"},{"location":"manual/feynman_rule/#Dressed-Propagator-and-Self-energy","page":"Feynman Rules","title":"Dressed Propagator and Self-energy","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The dressed propagator is given by,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G(tau k) = leftmathcalT psi(k tau) barpsi(k 0) right","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"and we define the self-energy Sigma as the one-particle irreducible vertex function,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G^-1 = g^-1 + Sigma","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"so that","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G = g - gSigma g + gSigma g Sigma g - ","category":"page"},{"location":"manual/feynman_rule/#Perturbative-Expansion-of-the-Green's-Function","page":"Feynman Rules","title":"Perturbative Expansion of the Green's Function","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Sign rule for the Wick contractions.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the Green's function.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of a Green's function diagram is given by (-1)^n_v xi^n_F, where","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"n_v is the number of interactions.\nn_F is the number of the fermionic loops.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-Self-energy","page":"Feynman Rules","title":"Feynman Rules for the Self-energy","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"From the Green's function diagrams, one can derive the negative self-energy diagram,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the self-energy.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"beginaligned\n-Sigma =  (-1) xi V_34 g_44+(-1) V_34 g_34 \n+(-1)^2 xi V_34 V_56 g_46 g_64 g_43+(-1)^2 V_34 V_56 g_35 g_54 g_42+cdots\nendaligned","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of a negative self-energy -Sigma diagram is given by (-1)^n_v xi^n_F, where","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"n_v is the number of interactions.\nn_F is the number of the fermionic loops.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-3-point-Vertex-Function","page":"Feynman Rules","title":"Feynman Rules for the 3-point Vertex Function","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The self-energy is related to the 3-point vertex function through an equation,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"-left(Sigma_3 x -Sigma^Hartree_3 xright) = G_3y cdot left(-V_3 4right) cdot Gamma^3_4yx","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the indices x y could be different from diagrams to diagrams, and Gamma_3 is the inproper three-vertex function. Eliminate the additional sign, one derives,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Sigma_3 x -Sigma^Hartree_3 x = G_3y cdot V_3 4 cdot Gamma^3_4yx","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the 3-point vertex function.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The diagram weights are given by,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"beginaligned\nGamma^(3)=  1 + (-1) xi V_56 g_46 g_64 + (-1) V_56 g_54 g_46\n+(-1)^2 xi^2 V_56 V_78 g_46 g_64 g_58 g_85+(-1)^2xi V_56 V_78 g_74 g_46+cdots\nendaligned","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of Gamma^(3) diagram is given by (-1)^n_v xi^n_F.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-4-point-Vertex-Function","page":"Feynman Rules","title":"Feynman Rules for the 4-point Vertex Function","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The 4-point vertex function is related to the 3-point vertex function through an equation,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Gamma^(3)_4yx = xi cdot G_4s cdot G_t 4 cdot Gamma^(4)_s t y x","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the indices x y s t could be different from diagrams to diagrams.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the 4-point vertex function.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The diagram weights are given by,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"beginaligned\nGamma^(4)=  (-1) V_56^textdirect + (-1)xi V_56^exchange\n+(-1)^2 xi V_56 V_78 g_58 g_85+(-1)^2 V_56 V_78+cdots\nendaligned","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where we used the identity xi^2 = 1.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of Gamma^(4) diagram is given by (-1)^n_v xi^n_F multiplied with a sign from the permutation of the external legs.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-Susceptibility","page":"Feynman Rules","title":"Feynman Rules for the Susceptibility","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The susceptibility can be derived from Gamma^(4).","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"chi_12 equiv leftmathcalT n_1 n_2right_textconnected = xi G_12 G_2 1 + xi G_1s G_t 1 Gamma^(4)_s t y x G_2y G_x 2","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the susceptibility.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"We define the polarization P as the one-interaction irreducible (or proper) vertex function,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"chi^-1 = P^-1 + V","category":"page"},{"location":"lib/taylorseries/#Taylor-expansions-in-independent-variables-(support-AbstractGraph)","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Taylor expansions in independent variables (support AbstractGraph)","text":"","category":"section"},{"location":"lib/taylorseries/#API","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"API","text":"","category":"section"},{"location":"lib/taylorseries/","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Taylor expansions in independent variables (support AbstractGraph)","text":"Modules = [FeynmanDiagram.Taylor]","category":"page"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor","text":"TaylorSeries\n\nA Julia package for Taylor expansions in one or more independent variables.\n\nThe basic constructors is TaylorSeries.\n\n\n\n\n\n","category":"module"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.ParamsTaylor","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.ParamsTaylor","text":"ParamsTaylor\n\nDataType holding the current parameters for `TaylorSeries`. \nThis part of code is adopted from TaylorSeries.jl (https://github.com/JuliaDiff/TaylorSeries.jl)\n\nFields:\n\norders            :: Int  Orders (degree) of the polynomials\nnum_vars         :: Int  Number of variables\nvariable_names   :: Vector{String}  Names of the variables\nvariable_symbols :: Vector{Symbol}  Symbols of the variables\n\nThese parameters can be changed using set_variables\n\n\n\n\n\n","category":"type"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.TaylorSeries","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.TaylorSeries","text":"mutable struct TaylorSeries{T}\n\nA representation of a taylor series.\n\nMembers:\n\nname::Symbol  name of the diagram\ncoeffs::Dict{Vector{Int},T}  The taylor expansion coefficients. The integer array define the order of corresponding coefficient. \n\n\n\n\n\n","category":"type"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.TaylorSeries-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.TaylorSeries","text":"function TaylorSeries(::Type{T}, nv::Int) where {T}\n\nCreate a taylor series equal to variable with index nv. For example, if global variables are \"x y\", in put nv=2 generate series t=y.\n\nArguments:\n\n::Type{T}  DataType of coefficients in taylor series.\nnv::Int  Index of variable. \n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:*-Union{Tuple{T}, Tuple{FeynmanDiagram.Taylor.TaylorSeries{T}, FeynmanDiagram.Taylor.TaylorSeries{T}}} where T","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:*","text":"function Base.:*(g1::TaylorSeries{T}, g2::TaylorSeries{T}) where {T}\n\nReturns a taylor series `g1 * g2` representing the product of `g2` with `g1`.\n\nArguments:\n\ng1  First taylor series\ng2  Second taylor series\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:*-Union{Tuple{T}, Tuple{FeynmanDiagram.Taylor.TaylorSeries{T}, Number}} where T","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:*","text":"function Base.:*(g1::TaylorSeries{T}, c2::Number) where {T}\n\nReturns a TaylorSeries representing the scalar multiplication `g1*c2`.\n\nArguments:\n\ng1  TaylorSeries\nc2  scalar multiple\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:*-Union{Tuple{T}, Tuple{Number, FeynmanDiagram.Taylor.TaylorSeries{T}}} where T","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:*","text":"function Base.:*(c1::Number, g2::TaylorSeries{T}) where {T}\n\nReturns a TaylorSeries representing the scalar multiplication `g2*c1`.\n\nArguments:\n\ng2  TaylorSeries\nc1  scalar multiple\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:+-Union{Tuple{S}, Tuple{T}, Tuple{FeynmanDiagram.Taylor.TaylorSeries{T}, S}} where {T, S<:Number}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:+","text":"function Base.:+(g1::TaylorSeries{T}, c::S) where {T,S<:Number}\n\nReturns a taylor series `g1 + c` representing the addition of constant `c` with `g1`.\n\nArguments:\n\ng1  Taylor series\nc  Constant\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:+-Union{Tuple{T}, Tuple{FeynmanDiagram.Taylor.TaylorSeries{T}, FeynmanDiagram.Taylor.TaylorSeries{T}}} where T","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:+","text":"function Base.:+(g1::TaylorSeries{T}, g2::TaylorSeries{T}) where {T}\n\nReturns a taylor series `g1 + g2` representing the addition of `g2` with `g1`.\n\nArguments:\n\ng1  First taylor series\ng2  Second taylor series\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:+-Union{Tuple{T}, Tuple{S}, Tuple{S, FeynmanDiagram.Taylor.TaylorSeries{T}}} where {S<:Number, T}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:+","text":"function Base.:+(c::S, g1::TaylorSeries{T}) where {S<:Number,T}\n\nReturns a taylor series `g1 + c` representing the addition of constant `c` with `g1`.\n\nArguments:\n\ng1  Taylor series\nc  Constant\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:--Union{Tuple{T}, Tuple{FeynmanDiagram.Taylor.TaylorSeries{T}, FeynmanDiagram.Taylor.TaylorSeries{T}}} where T","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:-","text":"function Base.:-(g1::TaylorSeries{T,V}, g2::TaylorSeries{T,V}) where {T,V}\n\nReturns a taylor series `g1 - g2` representing the difference of `g2` with `g1`.\n\nArguments:\n\ng1  First taylor series\ng2  Second taylor series\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.:^-Tuple{FeynmanDiagram.Taylor.TaylorSeries, Integer}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.:^","text":"function Base.:^(x::TaylorSeries, p::Integer)\n\nReturn the power of taylor series x^p, where p is an integer.\n\nArguments:\n\nx  Taylor series\n'p' Power index\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#Base.one-Union{Tuple{FeynmanDiagram.Taylor.TaylorSeries{T}}, Tuple{T}} where T","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"Base.one","text":"function  Base.one(g::TaylorSeries{T}) where {T}\n\nReturn a constant one for a given taylor series.\n\nArguments:\n\ng  Taylor series\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.displayBigO-Tuple{Bool}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.displayBigO","text":"displayBigO(d::Bool) --> nothing\n\nSet/unset displaying of the big 𝒪 notation in  the output of Taylor1 and TaylorN polynomials. The initial value is true.\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.getcoeff-Tuple{FeynmanDiagram.Taylor.TaylorSeries, Vector{Int64}}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.getcoeff","text":"function getcoeff(g::TaylorSeries, order::Vector{Int})\n\nReturn the taylor coefficients with given order in taylor series g.\n\nArguments:\n\ng  Taylor series\norder  Order of target coefficients\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.getderivative-Tuple{FeynmanDiagram.Taylor.TaylorSeries, Vector{Int64}}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.getderivative","text":"function getderivative(g::TaylorSeries, order::Vector{Int})\n\nReturn the derivative with given order in taylor series g.\n\nArguments:\n\ng  Taylor series\norder  Order of derivative\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.set_variables-Union{Tuple{T}, Tuple{R}, Tuple{Type{R}, Vector{T}}} where {R, T<:AbstractString}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.set_variables","text":"set_variables([T::Type], names::String; [orders=get_orders(), numvars=-1])\n\nReturn a TaylorSeries{T} vector with each entry representing an independent variable. names defines the output for each variable (separated by a space). The default type T is Float64, and the default for orders is the one defined globally.\n\nIf numvars is not specified, it is inferred from names. If only one variable name is defined and numvars>1, it uses this name with subscripts for the different variables.\n\njulia> set_variables(Int, \"x y z\", orders=[4,4,4])\n3-element Array{TaylorSeries.Taylor{Int},1}:\n  1 x + 𝒪(x⁵y⁵z⁵)\n  1 y + 𝒪(x⁵y⁵z⁵)\n  1 z + 𝒪(x⁵y⁵z⁵)\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.taylor_binomial-Tuple{Vector{Int64}, Vector{Int64}}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.taylor_binomial","text":"function taylor_binomial(o1::Vector{Int}, o2::Vector{Int})\n\nReturn the taylor binomial prefactor when product two high-order derivatives with order o1 and o2.\n\n# Arguments:\n- `o1`  Order of first derivative\n- `o2`  Order of second derivative\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.taylor_factorial-Tuple{Vector{Int64}}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.taylor_factorial","text":"function taylor_factorial(o::Vector{Int})\n\nReturn the taylor factorial prefactor with order o.\n\n# Arguments:\n- `o`  Order of the taylor coefficient\n\n\n\n\n\n","category":"method"},{"location":"lib/taylorseries/#FeynmanDiagram.Taylor.use_show_default-Tuple{Bool}","page":"Taylor expansions in independent variables (support AbstractGraph)","title":"FeynmanDiagram.Taylor.use_show_default","text":"use_Base_show(d::Bool) --> nothing\n\nUse Base.show_default method (default show method in Base), or a custom display. The initial value is false, so customized display is used.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FeynmanDiagram","category":"page"},{"location":"#FeynmanDiagram","page":"Home","title":"FeynmanDiagram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FeynmanDiagram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FeynmanDiagram]","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/operator.md\",\n    \"lib/computgraph.md\",\n    \"lib/taylorseries.md\",\n    \"lib/frontend.md\",\n    \"lib/GV.md\",\n    \"lib/parquet.md\",\n    \"lib/backend.md\",\n    \"lib/utility.md\",\n]\nDepth = 2","category":"page"},{"location":"lib/GV/#GV-expansion-to-a-computational-graph","page":"GV expansion to a computational graph","title":"GV expansion to a computational graph","text":"","category":"section"},{"location":"lib/GV/#API","page":"GV expansion to a computational graph","title":"API","text":"","category":"section"},{"location":"lib/GV/","page":"GV expansion to a computational graph","title":"GV expansion to a computational graph","text":"Modules = [FeynmanDiagram.GV]","category":"page"},{"location":"lib/GV/#FeynmanDiagram.FrontEnds.GV.diagsGV-Tuple{Symbol, Int64, Int64, Int64}","page":"GV expansion to a computational graph","title":"FeynmanDiagram.FrontEnds.GV.diagsGV","text":"function diagsGV(type::Symbol, order::Int, GOrder::Int=0, VerOrder::Int=0;\n    labelProd::Union{Nothing,LabelProduct}=nothing, spinPolarPara::Float64=0.0,\n    tau_labels::Union{Nothing,Vector{Int}}=nothing, filter::Vector{Filter}=[NoHartree])\n\nGenerates a `Vector{FeynmanGraph}`: the given-`type` diagrams with static interactions of a given order, where the actual order of diagrams equals to `order + VerOrder + 2 * GOrder`.\nGenerates a `LabelProduct`: `labelProd` with inputs `tau_labels` and all the possible momenta-loop basis. \nGenerates external tau labels Vector{Vector{Int}}. The i-th labels (Vector{Int}) corresponds to the i-th `FeynmanGraph` in `Vector{FeynmanGraph}`.\n\nArguments:\n\ntype (Symbol): The type of the diagrams, including :spinPolar, :chargePolar, :sigma, :green, or :freeEnergy.\norder (Int): The order of the diagrams without counterterms.\nGOrder (Int): The order of self-energy counterterms.\nVerOrder (Int): The order of interaction counterterms.\nlabelProd (Union{Nothing,LabelProduct}=nothing, optional): The initial cartesian QuantumOperator.label product (defaults to nothing).\nspinPolarPara (Float64, optional): The spin-polarization parameter (nup - ndown) / (nup + ndown) (defaults to 0.0).\ntau_labels(Union{Nothing, Vector{Int}}, optional): The labels for the discrete time of each vertex. (defaults to nothing).\n\nReturns\n\nA tuple (diagrams, fermi_labelProd, bose_labelProd, extT_labels) where \n\ndiagrams is a Vector{FeynmanGraph} object representing the diagrams, \nlabelProd is a LabelProduct object containing the labels for the leaves of graphs, \nextT_labels is a Vector{Union{Tuple,Vector{Int}}} object containing the external tau labels for each FeynmanGraph in diagrams.\n\n\n\n\n\n","category":"method"},{"location":"lib/GV/#FeynmanDiagram.FrontEnds.GV.diagsGV_ver4-Tuple{Int64}","page":"GV expansion to a computational graph","title":"FeynmanDiagram.FrontEnds.GV.diagsGV_ver4","text":"function diagsGV_ver4(order::Int; spinPolarPara::Float64=0.0, filter::Vector{Filter}=[NoHartree], channels=[PHr, PHEr, PPr, Alli])\n\nGenerates a `Vector{Graph}`: the 4-point vertex diagrams with static interactions of a given order.\n\nArguments:\n\norder (Int): The order of the diagrams without counterterms.\nspinPolarPara (Float64, optional): The spin-polarization parameter (nup - ndown) / (nup + ndown) (defaults to 0.0).\nchannels (optional): The channels for the diagrams, defaults to [PHr, PHEr, PPr, Alli].\nfilter (optional): Filter criteria for the diagrams, defaults to [NoHartree].\n\n\n\n\n\n","category":"method"},{"location":"lib/GV/#FeynmanDiagram.FrontEnds.GV.read_diagrams-Tuple{AbstractString}","page":"GV expansion to a computational graph","title":"FeynmanDiagram.FrontEnds.GV.read_diagrams","text":"function read_diagrams(filename::AbstractString; loopPool::Union{LoopPool,Nothing}=nothing,\n    dim::Int=3, tau_labels::Union{Nothing,Vector{Int}}=nothing, GTypes=[0, 1], VTypes=[0, 1, 2],\n    keywords::Vector{String}=[\"Polarization\", \"DiagNum\", \"Order\", \"GNum\", \"Ver4Num\", \"LoopNum\", \"ExtLoopIndex\",\n        \"DummyLoopIndex\", \"TauNum\", \"ExtTauIndex\", \"DummyTauIndex\"])\n\nReads a GV_diagrams file and returns FeynmanGraph of diagrams in this file \nand the corresponding `LabelProduct` objects, which are used to keep track of QuantumOperator.label.\n\nArguments:\n\nfilename (AbstractString): The path to the file containing the diagrams.\nloopPool (Union{LoopPool,Nothing}): An optional LoopPool object. If not provided, a new one will be created.\nspinPolarPara (Float64): The spin-polarization parameter (nup - ndown) / (nup + ndown) (defaults to 0.0).\ndim (Int): The dimension of the system, used to initialize the LoopPool object. Default is 3.\ntau_labels (Union{Nothing,Vector{Int}}): The labels for the Tau objects in the diagrams. If not provided, they will be set to the integers from 1 to tauNum.\nGTypes (Vector{Int}): The labels for the fermionic G objects in the diagrams. Default is [0, 1].\nVTypes (Vector{Int}): The labels for the bosonic V objects in the diagrams. Default is [0, 1, 2].\nkeywords (Vector{String}): A set of keywords used to extract information from the file. Default is [\"Polarization\", \"DiagNum\", \"Order\", \"GNum\", \"Ver4Num\", \"LoopNum\", \"ExtLoopIndex\", \"DummyLoopIndex\", \"TauNum\", \"ExtTauIndex\", \"DummyTauIndex\"].\n\nReturns\n\nA tuple (diagrams, fermi_labelProd, bose_labelProd) where \n\ndiagrams is a FeynmanGraph object representing the diagrams, \nfermi_labelProd is a LabelProduct object containing the labels for the fermionic G objects in the diagrams, \nbose_labelProd is a LabelProduct object containing the labels for the bosonic W objects in the diagrams.\n\n\n\n\n\n","category":"method"},{"location":"manual/counterterms/#Evaluation-of-counterterms","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"For illustrative simplicity, let us consider the renormalization of the chemical potential and Yukawa effective mass in the uniform electron gas (UEG). Following the Negele & Orland conventions, the non-interacting Green's function g is given by","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g(mathbfk iomega_n) = -frac1iomega_n-epsilon_mathbfk + mu","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where G is the bold Green's function, omega_n = 2pi (n+1)beta is a fermionic Matsubara frequency, and mu is the exact chemical potential derived from the interacting density n. The 1PI self-energy Sigma is then defined through the following Dyson equation:","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" G^-1 = g^-1 + Sigma implies G = g - gSigma g + gSigma g Sigma g - ","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Following the variational diagrammatic Monte-Carlo (VDMC) approach, we rewrite the bare Green's function g in terms of a renormalized propagator g_R, writing","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g(mathbfk iomega_n) = -frac1iomega_n-epsilon_mathbfk + mu_R + deltamu","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where, motivated by Luttinger's theorem, the renormalized chemical potential mu_R = mu - deltamu equiv epsilon_F = k^2_F  2 m is chosen so as to preserve the non-interacting Fermi surface, whereas lambda is taken as a fixed, non-zero constant.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Similarly, the Coulomb interaction is re-written as","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" V(q) = frace^2epsilon_0 q^2 = frace^2epsilon_0 frac1q^2 + lambda + deltalambda","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"We then work perturbatively in terms of the following renormalized Green's function and interaction,","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n g_R(k iomega_n) equiv -frac1iomega_n-epsilon_k + mu_R = g(k iomega_n) Big_deltamu = 02ex\n V_lambda(q) equiv frace^2epsilon_0 frac1q^2 + lambda = V(q) Big_deltalambda = 0\nendaligned","category":"page"},{"location":"manual/counterterms/#New-approach-to-counterterm-evaluation","page":"Evaluation of counterterms","title":"New approach to counterterm evaluation","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"In the NEFT codebase, the counterterms are generated by directly differentiating diagrams in the perturbative series for a given observable, which allows for a flexible and generic reformulation of the VDMC algorithm. This is made possible by representing all diagrams by differentiable expression trees. In contrast, in the original VDMC approach one first Taylor expands all propagators gg_R and VV_lambda entering a given observable by hand and collects terms in orders of xi manually prior to integration.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"The mathcalO(xi^N) counterterms in RPT with n and m chemical potential / interaction derivatives are given by","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" (deltamu)^n (deltalambda)^m times frac1n mpartial^n_mu partial^m_lambda D_N - n - m","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where D is the sum of all Feynman diagrams at the appropriate loop order N - n - m. The renormalization is performed in post-processing by multiplying with the Taylor series for (deltamu)^n (deltalambda)^m in xi and collecting terms propto xi^N. The chemical potential shift delta mu_n is derived from a separate MC simulation of Sigma^lambda_R_F(k_F ik_0).","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"To demonstrate that the two approaches outlined above are equivalent, it is sufficient to consider separately the cases of V and g raised to an arbitrary power in the Matsubara representation; we will omit the coordinates for brevity.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"First, consider the chemical potential counterterms. Let deltamu equiv mu_0 - mu_R. Taylor expanding gg_R about deltamu = 0, we have","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g = fracg_R1 - g_Rdeltamu = g_Rsum^infty_n=0 (g_Rdeltamu)^n = sum^infty_n=0 frac(deltamu)^nn partial^n_mu g_R","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"since","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g^n+1_R = frac1n partial^n_mu g_R","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Then,","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n g^m  = left(sum^infty_n=0 frac(deltamu)^nn partial^n_mu g_Rright)^m = g^m_Rleft(1 - g_Rdeltamuright)^-m = g^m_R sum^infty_n=0 binomm+n-1n (g_Rdeltamu)^n\n      = sum^infty_n=0 (deltamu)^n frac(m+n-1)n (m-1) g^m+n_R = sum^infty_n=0 frac(deltamu)^nn (m-1) partial^m+n-1_mu g_R = sum^infty_n=0 frac(deltamu)^nn partial^n_mu g^m_R\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where in the last step, we replaced","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n frac1(m-1) partial^m-1_mu g_R = g^m_R\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Thus, the series for g^m may be represented either by expanding each gg_R by hand and collecting terms, or by a direct Taylor expansion of g^m about deltamu = 0.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"It remains to show that these two strategies are also equivalent for the expansion of V^m. Let deltalambda equiv lambda_0 - lambda_R = -lambda_R and Taylor expand VV_lambda about deltalambda = 0—we obtain","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"\n  V = fracV_ lambda1 - fraclambdaq^2 + lambda = V_lambda sum_n=0^infty left(fraclambdaq^2 + lambdaright)^n = V_lambda sum_n=0^infty left(V_lambda deltalambdaright)^n = sum^infty_n=0 frac(-lambda)^nn partial^n_lambda V_lambda\n","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" V = fracV_ lambda1 - delta_lambda = V_lambda sum_n=0^infty delta^n_lambda = sum^infty_n=0 frac(deltalambda)^nn partial^n_lambda V_lambda","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" delta_lambda equiv fraclambdaq^2 + lambda","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"since","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n frac(deltalambda)^nn partial^n_lambda V_lambda = 8pifrac(-lambda)^nn partial^n_lambda left(frac1q^2 + lambdaright) = frac8pilambda^n(q^2 + lambda)^n+1 = V_lambda delta^n_lambda\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"We also have that","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n frac(deltalambda)^nn partial^n_lambda V^m_lambda = left(fraclambda8piright)^n fracm^(n)n V^m+n_lambda = binomm + n - 1n V^m_lambda delta^n_lambda\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where m^(n) = prod_i=0^n-1 (m + i) is a rising factorial and","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" binomm + n - 1n = frac(m + n - 1)n (m-1) = fracm^(n)n","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Thus,","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n V^m  = left(sum^infty_n=0 frac(deltalambda)^nn partial^n_lambda V_lambdaright)^m = V^m_lambda left(1 - delta_lambdaright)^-m = sum^infty_n=0 binomm+n-1n V^m_lambda delta^n_lambda = sum^infty_n=0 frac(deltalambda)^nn partial^n_lambda V^m_lambda\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Since the order of differentiation w.r.t. mu and lambda does not matter, it follows that a general diagram mathcalDg V sim g^n V^m may be represented either by pre-expanding gg_mu and VV_lambda and collecting terms, or by directly evaluating terms in the Taylor series for mathcalDg_mu V_lambda; this codebase uses the latter approach.","category":"page"},{"location":"manual/counterterms/#Evaluation-of-interaction-counterterms","page":"Evaluation of counterterms","title":"Evaluation of interaction counterterms","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"An example of the interaction counterterm evaluation for a diagram with n_lambda = 3 and m interaction lines. Since the Julia implementation evaluates the interaction counterterms of a given diagram as frac(-lambda)^nnpartial^n_lambda V^m_lambda, we pick up an extra factor of l on each lth-order derivative in the chain rule.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"(Image: An example of the representation of interaction counterterm diagrams via differentiation.)","category":"page"},{"location":"manual/counterterms/#Benchmark-of-counterterms-in-the-UEG","page":"Evaluation of counterterms","title":"Benchmark of counterterms in the UEG","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"As a concrete example, we have evaluated the individual diagrams and associated counterterms entering the RPT series for the total density ng_mu V_lambda in units of the non-interacting density n_0. The diagrams/counterterms are denoted by partitions mathcalP equiv (n_textloop n_mu n_lambda) indicating the total loop order and number of mu and lambda derivatives.","category":"page"},{"location":"manual/counterterms/#3D-UEG","page":"Evaluation of counterterms","title":"3D UEG","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"For this benchmark, we take r_s = 1, beta = 40 epsilon_F, and lambda = 06. All partitions contributing up to 4th order are included, as well as some selected partitions at 5th and 6th order.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"(n_textloop n_lambda n_mu) n  n_0\n(1, 0, 1) 0.40814(16)\n(1, 0, 2) 0.02778(21)\n(1, 0, 3) -0.00096(60)\n(2, 0, 0) 0.28853(12)\n(2, 1, 0) 0.07225(3)\n(2, 2, 0) 0.02965(2)\n(2, 0, 1) 0.09774(30)\n(2, 1, 1) 0.01594(10)\n(2, 0, 2) 0.00240(130)\n(3, 0, 0) 0.10027(37)\n(3, 1, 0) 0.04251(21)\n(3, 0, 1) 0.02600(150)\n(4, 0, 0) 0.00320(130)\n(2, 1, 2) -0.00111(18)\n(2, 0, 3) -0.00430(150)\n(3, 2, 0) 0.02241(8)\n(3, 3, 0) 0.01429(7)","category":"page"}]
}
